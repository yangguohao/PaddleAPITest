{
    "paddle.abs": {
        "torch_api": "torch.abs",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.abs": {
        "torch_api": "torch.Tensor.abs",
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.abs()"
    },
    "paddle.acos": {
        "torch_api": "torch.arccos",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.acosh": {
        "torch_api": "torch.arccosh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.add": {
        "torch_api": "torch.add",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        },
        "torch_args": [],
        "torch_kwargs": {
            "alpha": 1
        },
        "description": "result = torch.add(input=x, other=y, alpha=1)"
    },
    "paddle.Tensor.add": {
        "torch_api": "torch.Tensor.add",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.add(other=y)"
    },
    "paddle.add_n": {
        "Rule": "AddNRule"
    },
    "paddle.addmm": {
        "torch_api": "torch.addmm",
        "paddle_torch_args_map": {
            "input": "input",
            "x": "mat1",
            "y": "mat2",
            "beta": "beta",
            "alpha": "alpha"
        }
    },
    "paddle.all": {
        "Rule": "AllRule",
        "torch_api": "torch.all",
        "set_defaults": {
            "keepdim": false
        },
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.all": {
        "torch_api": "torch.Tensor.all",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.all(dim=dim, keepdim=keepdim)"
    },
    "paddle.allclose": {
        "Rule": "AllcloseRule",
        "torch_api": "torch.allclose",
        "set_defaults": {
            "rtol": 1e-05,
            "atol": 1e-08,
            "equal_nan": "False"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other",
            "rtol": "rtol",
            "atol": "atol",
            "equal_nan": "equal_nan"
        }
    },
    "paddle.amax": {
        "torch_api": "torch.amax",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.amax": {
        "torch_api": "torch.Tensor.amax",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.amin": {
        "torch_api": "torch.amin",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.amin": {
        "torch_api": "torch.Tensor.amin",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.angle": {
        "torch_api": "torch.angle",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.any": {
        "torch_api": "torch.any",
        "paddle_torch_args_map": {
            "x": "input",
            "keepdim": "keepdim"
        },
        "torch_kwargs": {
            "dim": "None if locals().get('axis') is None or locals().get('axis') == [] or locals().get('axis') == () else axis"
        }
    },
    "paddle.Tensor.any": {
        "torch_api": "torch.Tensor.any",
        "paddle_torch_args_map": {
            "keepdim": "keepdim"
        },
        "torch_kwargs": {
            "dim": "None if locals().get('axis') is None or locals().get('axis') == [] or locals().get('axis') == () else axis"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.any(dim=dim, keepdim=keepdim)"
    },
    "paddle.arange": {
        "torch_api": "torch.arange",
        "paddle_torch_args_map": {
            "dtype": "dtype"
        },
        "torch_kwargs": {
            "start": "0 if locals().get('start') is None else start.item() if isinstance(start, torch.Tensor) else start",
            "end": "end.item() if isinstance(end, torch.Tensor) else end",
            "step": "1 if locals().get('step') is None else step.item() if isinstance(step, torch.Tensor) else step"
        },
        "description": "result = torch.arange(start=start, end=end, step=step, dtype=dtype)"
    },
    "paddle.argmax": {
        "Rule": "ArgmaxRule",
        "torch_api": "torch.argmax",
        "paddle_torch_args_map": {
            "x": "input"
        },
        "torch_kwargs": {
            "dim": "None if locals().get('axis') is None else axis.item() if isinstance(axis, torch.Tensor) else axis",
            "keepdim": "False if locals().get('keepdim') is None else keepdim"
        },
        "description": "result = torch.argmax(input=x, dim=axis, keepdim=keepdim)"
    },
    "paddle.Tensor.argmax": {
        "Rule": "ArgmaxRule",
        "torch_api": "torch.Tensor.argmax",
        "torch_kwargs": {
            "dim": "None if locals().get('axis') is None else axis.item() if isinstance(axis, torch.Tensor) else axis",
            "keepdim": "False if locals().get('keepdim') is None else keepdim"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.argmax(dim=axis, keepdim=keepdim)"
    },
    "paddle.argmin": {
        "Rule": "ArgminRule",
        "torch_api": "torch.argmin",
        "set_defaults": {
            "axis": "None",
            "keepdim": false,
            "dtype": "torch.int64"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.argsort": {
        "torch_api": "torch.argsort",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "descending": "descending",
            "stable": "stable"
        }
    },
    "paddle.Tensor.argsort": {
        "torch_api": "torch.Tensor.argsort",
        "paddle_torch_args_map": {
            "axis": "dim",
            "descending": "descending",
            "stable": "stable"
        }
    },
    "paddle.as_complex": {
        "Rule": "AsComplexRule",
        "torch_api": "torch.view_as_complex",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.as_real": {
        "torch_api": "torch.view_as_real",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.as_strided": {
        "torch_api": "torch.as_strided",
        "paddle_torch_args_map": {
            "x": "input",
            "shape": "size",
            "stride": "stride",
            "offset": "storage_offset"
        },
        "description": "result = torch.as_strided(input=x, size=shape, stride=stride, storage_offset=offset)"
    },
    "paddle.asin": {
        "torch_api": "torch.arcsin",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.asinh": {
        "torch_api": "torch.arcsinh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.assign": {
        "Rule": "AssignRule",
        "torch_api": "torch.clone",
        "description": "result = torch.clone(input=x)"
    },
    "paddle.atan": {
        "torch_api": "torch.arctan",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.atan2": {
        "torch_api": "torch.arctan2",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.atanh": {
        "torch_api": "torch.arctanh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.atanh": {
        "torch_api": "torch.Tensor.atanh",
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.atanh()"
    },
    "paddle.atleast_1d": {
        "torch_api": "torch.atleast_1d",
        "torch_args": [
            "*inputs"
        ]
    },
    "paddle.atleast_2d": {
        "torch_api": "torch.atleast_2d",
        "torch_args": [
            "*inputs"
        ]
    },
    "paddle.atleast_3d": {
        "torch_api": "torch.atleast_3d",
        "torch_args": [
            "*inputs"
        ]
    },
    "paddle.audio.functional.get_window": {
        "Rule": "GetWindowRule"
    },
    "paddle.autograd.hessian": {
        "Rule": "HessianRule"
    },
    "paddle.autograd.jacobian": {
        "Rule": "JacobianRule"
    },
    "paddle.bernoulli": {
        "torch_api": "torch.bernoulli",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p",
            "generator": "generator"
        }
    },
    "paddle.bincount": {
        "torch_api": "torch.bincount",
        "set_defaults": {
            "weights": "None",
            "minlength": 0
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weights": "weights"
        },
        "torch_kwargs": {
            "minlength": "minlength.item() if torch.is_tensor(minlength) else minlength"
        }
    },
    "paddle.binomial": {
        "Rule": "BinomialRule",
        "description": "result = torch.distributions.binomial.Binomial(total_count=tcnt, probs=tprob).sample()"
    },
    "paddle.bitwise_and": {
        "torch_api": "torch.bitwise_and",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.bitwise_invert": {
        "torch_api": "torch.bitwise_not",
        "paddle_torch_args_map": {
            "x": "input",
            "out": "out"
        }
    },
    "paddle.bitwise_left_shift": {
        "torch_api": "torch.bitwise_left_shift",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.bitwise_not": {
        "torch_api": "torch.bitwise_not",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.bitwise_or": {
        "torch_api": "torch.bitwise_or",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.bitwise_right_shift": {
        "Rule": "__rshift__Rule"
    },
    "paddle.bitwise_xor": {
        "torch_api": "torch.bitwise_xor",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.bmm": {
        "torch_api": "torch.bmm",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "mat2"
        }
    },
    "paddle.Tensor.bmm": {
        "torch_api": "torch.Tensor.bmm",
        "paddle_torch_args_map": {
            "y": "mat2"
        }
    },
    "paddle.broadcast_shape": {
        "Rule": "BroadcastShapeRule"
    },
    "paddle.broadcast_tensors": {
        "Rule": "BroadcastTensorsRule"
    },
    "paddle.broadcast_to": {
        "torch_api": "torch.broadcast_to",
        "paddle_torch_args_map": {
            "x": "input",
            "shape": "size"
        }
    },
    "paddle.Tensor.broadcast_to": {
        "torch_api": "torch.Tensor.broadcast_to",
        "paddle_torch_args_map": {
            "shape": "size"
        }
    },
    "paddle.bucketize": {
        "torch_api": "torch.bucketize",
        "paddle_torch_args_map": {
            "x": "input",
            "sorted_sequence": "boundaries",
            "out_int32": "out_int32",
            "right": "right"
        }
    },
    "paddle.cartesian_prod": {
        "torch_api": "torch.cartesian_prod",
        "torch_args": [
            "*x"
        ]
    },
    "paddle.cast": {
        "Rule": "CastRule"
    },
    "paddle.Tensor.cast": {
        "Rule": "CastRule"
    },
    "paddle.cdist": {
        "torch_api": "torch.cdist",
        "paddle_torch_args_map": {
            "x": "x1",
            "y": "x2",
            "p": "p",
            "compute_mode": "compute_mode"
        }
    },
    "paddle.ceil": {
        "torch_api": "torch.ceil",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.ceil": {
        "torch_api": "torch.Tensor.ceil"
    },
    "paddle.chunk": {
        "Rule": "ChunkRule",
        "torch_api": "torch.chunk",
        "set_defaults": {
            "axis": "0"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "chunks": "chunks",
            "axis": "dim"
        }
    },
    "paddle.Tensor.chunk": {
        "torch_api": "torch.Tensor.chunk",
        "paddle_torch_args_map": {
            "chunks": "chunks",
            "axis": "dim"
        }
    },
    "paddle.clip": {
        "Rule": "ClipRule",
        "torch_api": "torch.clamp",
        "set_defaults": {
            "min": "None",
            "max": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "min": "min",
            "max": "max"
        }
    },
    "paddle.Tensor.clip": {
        "Rule": "ClipRule",
        "torch_api": "torch.clamp",
        "set_defaults": {
            "min": "None",
            "max": "None"
        },
        "paddle_torch_args_map": {
            "min": "min",
            "max": "max"
        }
    },
    "paddle.clone": {
        "torch_api": "torch.clone",
        "paddle_torch_args_map": {
            "x": "input",
            "memory_format": "memory_format"
        }
    },
    "paddle.Tensor.clone": {
        "torch_api": "torch.Tensor.clone",
        "paddle_torch_args_map": {
            "memory_format": "memory_format"
        }
    },
    "paddle.column_stack": {
        "torch_api": "torch.column_stack",
        "paddle_torch_args_map": {
            "x": "tensors"
        }
    },
    "paddle.combinations": {
        "torch_api": "torch.combinations",
        "paddle_torch_args_map": {
            "x": "input",
            "r": "r",
            "with_replacement": "with_replacement"
        }
    },
    "paddle.complex": {
        "torch_api": "torch.complex",
        "paddle_torch_args_map": {
            "real": "real",
            "imag": "imag"
        }
    },
    "paddle.concat": {
        "torch_api": "torch.concat",
        "paddle_torch_args_map": {
            "x": "tensors",
            "axis": "dim"
        }
    },
    "paddle.conj": {
        "torch_api": "torch.conj",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.conj": {
        "torch_api": "torch.Tensor.conj"
    },
    "paddle.copysign": {
        "torch_api": "torch.copysign",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.cos": {
        "torch_api": "torch.cos",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.cos": {
        "torch_api": "torch.Tensor.cos"
    },
    "paddle.cosh": {
        "torch_api": "torch.cosh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.count_nonzero": {
        "Rule": "CountNonzeroRule",
        "torch_api": "torch.count_nonzero",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim"
        }
    },
    "paddle.crop": {
        "Rule": "CropRule"
    },
    "paddle.cross": {
        "torch_api": "torch.cross",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other",
            "axis": "dim"
        }
    },
    "paddle.cummax": {
        "Rule": "CumRule",
        "torch_api": "torch.cummax"
    },
    "paddle.cummin": {
        "Rule": "CumRule",
        "torch_api": "torch.cummin"
    },
    "paddle.cumprod": {
        "Rule": "CumprodRule",
        "torch_api": "torch.cumprod"
    },
    "paddle.Tensor.cumprod": {
        "torch_api": "torch.Tensor.cumprod",
        "paddle_torch_args_map": {
            "dim": "dim",
            "dtype": "dtype"
        }
    },
    "paddle.cumsum": {
        "Rule": "CumsumRule",
        "torch_api": "torch.cumsum",
        "set_defaults": {
            "axis": "None",
            "dtype": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "dtype": "dtype"
        }
    },
    "paddle.Tensor.cumsum": {
        "Rule": "CumsumRule",
        "torch_api": "torch.Tensor.cumsum",
        "set_defaults": {
            "axis": "None",
            "dtype": "None"
        },
        "paddle_torch_args_map": {
            "axis": "dim",
            "dtype": "dtype"
        }
    },
    "paddle.cumulative_trapezoid": {
        "Rule": "CumulativeTrapezoidRule",
        "torch_api": "torch.cumulative_trapezoid",
        "set_defaults": {
            "x": "None",
            "dx": "None",
            "axis": -1
        },
        "paddle_torch_args_map": {
            "y": "y",
            "x": "x",
            "dx": "dx",
            "axis": "dim"
        }
    },
    "paddle.deg2rad": {
        "torch_api": "torch.deg2rad",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.diag": {
        "Rule": "DiagRule",
        "torch_api": "torch.diag",
        "set_defaults": {
            "offset": "0",
            "padding_value": "0"
        }
    },
    "paddle.Tensor.diag": {
        "Rule": "DiagRule",
        "torch_api": "torch.Tensor.diag",
        "set_defaults": {
            "offset": "0",
            "padding_value": "0"
        }
    },
    "paddle.diag_embed": {
        "torch_api": "torch.diag_embed",
        "paddle_torch_args_map": {
            "input": "input",
            "offset": "offset",
            "dim1": "dim1",
            "dim2": "dim2"
        }
    },
    "paddle.Tensor.diag_embed": {
        "torch_api": "torch.Tensor.diag_embed",
        "paddle_torch_args_map": {
            "offset": "offset",
            "dim1": "dim1",
            "dim2": "dim2"
        }
    },
    "paddle.diagflat": {
        "torch_api": "torch.diagflat",
        "paddle_torch_args_map": {
            "x": "input",
            "offset": "offset"
        }
    },
    "paddle.diagonal": {
        "torch_api": "torch.diagonal",
        "paddle_torch_args_map": {
            "x": "input",
            "offset": "offset",
            "axis1": "dim1",
            "axis2": "dim2"
        }
    },
    "paddle.Tensor.diagonal": {
        "torch_api": "torch.Tensor.diagonal",
        "paddle_torch_args_map": {
            "offset": "offset",
            "axis1": "dim1",
            "axis2": "dim2"
        }
    },
    "paddle.diagonal_scatter": {
        "torch_api": "torch.diagonal_scatter",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "src",
            "offset": "offset",
            "axis1": "dim1",
            "axis2": "dim2"
        }
    },
    "paddle.diff": {
        "torch_api": "torch.diff",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "prepend": "prepend",
            "append": "append"
        }
    },
    "paddle.Tensor.diff": {
        "torch_api": "torch.Tensor.diff",
        "paddle_torch_args_map": {
            "n": "n",
            "axis": "dim",
            "prepend": "prepend",
            "append": "append"
        }
    },
    "paddle.digamma": {
        "torch_api": "torch.special.digamma",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.digamma": {
        "torch_api": "torch.Tensor.digamma"
    },
    "paddle.dist": {
        "torch_api": "torch.dist",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other",
            "p": "p"
        }
    },
    "paddle.divide": {
        "torch_api": "torch.divide",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.divide": {
        "torch_api": "torch.Tensor.true_divide",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.dot": {
        "Rule": "DotRule",
        "torch_api": "torch.dot"
    },
    "paddle.Tensor.dot": {
        "Rule": "DotRule",
        "torch_api": "torch.Tensor.dot"
    },
    "paddle.dsplit": {
        "Rule": "SsplitRule",
        "torch_api": "torch.dsplit",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.dstack": {
        "torch_api": "torch.dstack",
        "paddle_torch_args_map": {
            "x": "tensors"
        }
    },
    "paddle.einsum": {
        "Rule": "EinsumRule",
        "torch_api": "torch.einsum"
    },
    "paddle.empty": {
        "Rule": "EmptyRule"
    },
    "paddle.empty_like": {
        "torch_api": "torch.empty_like",
        "paddle_torch_args_map": {
            "x": "input",
            "dtype": "dtype"
        }
    },
    "paddle.equal": {
        "torch_api": "torch.eq",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.equal": {
        "torch_api": "torch.Tensor.eq",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.equal_all": {
        "torch_api": "torch.equal",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.equal_all": {
        "torch_api": "torch.Tensor.equal",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.erf": {
        "torch_api": "torch.special.erf",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.erfinv": {
        "torch_api": "torch.special.erfinv",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.erfinv": {
        "torch_api": "torch.Tensor.erfinv"
    },
    "paddle.exp": {
        "torch_api": "torch.exp",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.exp": {
        "torch_api": "torch.Tensor.exp"
    },
    "paddle.expand": {
        "Rule": "ExpandRule"
    },
    "paddle.Tensor.expand": {
        "Rule": "ExpandRule"
    },
    "paddle.expand_as": {
        "Rule": "ExpandasRule"
    },
    "paddle.Tensor.expand_as": {
        "torch_api": "torch.Tensor.expand_as",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.expm1": {
        "torch_api": "torch.special.expm1",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.eye": {
        "Rule": "EyeRule",
        "torch_api": "torch.eye",
        "set_defaults": {
            "dtype": "None",
            "num_columns": "None"
        },
        "paddle_torch_args_map": {
            "dtype": "dtype",
            "num_columns": "m",
            "num_rows": "n"
        }
    },
    "paddle.fft.fft": {
        "torch_api": "torch.fft.fft",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.fft2": {
        "torch_api": "torch.fft.fft2",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.fftfreq": {
        "torch_api": "torch.fft.fftfreq",
        "paddle_torch_args_map": {
            "n": "n",
            "d": "d",
            "dtype": "dtype",
            "layout": "layout",
            "device": "device",
            "requires_grad": "requires_grad"
        }
    },
    "paddle.fft.fftn": {
        "torch_api": "torch.fft.fftn",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.fftshift": {
        "torch_api": "torch.fft.fftshift",
        "paddle_torch_args_map": {
            "x": "input",
            "axes": "dim"
        }
    },
    "paddle.fft.hfft": {
        "torch_api": "torch.fft.hfft",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.hfft2": {
        "torch_api": "torch.fft.hfft2",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.hfftn": {
        "torch_api": "torch.fft.hfftn",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.ifft": {
        "torch_api": "torch.fft.ifft",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.ifft2": {
        "torch_api": "torch.fft.ifft2",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.ifftn": {
        "torch_api": "torch.fft.ifftn",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.ifftshift": {
        "torch_api": "torch.fft.ifftshift",
        "paddle_torch_args_map": {
            "x": "input",
            "axes": "dim"
        }
    },
    "paddle.fft.ihfft": {
        "torch_api": "torch.fft.ihfft",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.ihfft2": {
        "torch_api": "torch.fft.ihfft2",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.ihfftn": {
        "torch_api": "torch.fft.ihfftn",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.irfft": {
        "torch_api": "torch.fft.irfft",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.irfft2": {
        "torch_api": "torch.fft.irfft2",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.irfftn": {
        "torch_api": "torch.fft.irfftn",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.rfft": {
        "torch_api": "torch.fft.rfft",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n",
            "axis": "dim",
            "norm": "norm"
        }
    },
    "paddle.fft.rfft2": {
        "torch_api": "torch.fft.rfft2",
        "set_defaults": {
            "s": "None",
            "norm": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "norm": "norm"
        },
        "torch_kwargs": {
            "dim": "(-2, -1) if locals().get('axes') is None else axes"
        }
    },
    "paddle.fft.rfftfreq": {
        "torch_api": "torch.fft.rfftfreq",
        "paddle_torch_args_map": {
            "n": "n",
            "d": "d",
            "dtype": "dtype",
            "layout": "layout",
            "device": "device",
            "requires_grad": "requires_grad"
        }
    },
    "paddle.fft.rfftn": {
        "torch_api": "torch.fft.rfftn",
        "paddle_torch_args_map": {
            "x": "input",
            "s": "s",
            "axes": "dim",
            "norm": "norm"
        }
    },
    "paddle.flatten": {
        "torch_api": "torch.flatten",
        "paddle_torch_args_map": {
            "x": "input",
            "start_axis": "start_dim",
            "stop_axis": "end_dim"
        }
    },
    "paddle.Tensor.flatten": {
        "torch_api": "torch.Tensor.flatten",
        "paddle_torch_args_map": {
            "start_axis": "start_dim",
            "stop_axis": "end_dim"
        }
    },
    "paddle.flip": {
        "torch_api": "torch.flip",
        "paddle_torch_args_map": {
            "x": "input"
        },
        "torch_kwargs": {
            "dims": "[axis] if isinstance(axis, int) else axis"
        },
        "description": "no need to use locals().get('axis') sice axis is a positional argument without default value (must input)"
    },
    "paddle.Tensor.flip": {
        "torch_api": "torch.Tensor.flip",
        "torch_kwargs": {
            "dims": "tuple([axis]) if isinstance(axis, int) else tuple(axis)"
        }
    },
    "paddle.floor": {
        "torch_api": "torch.floor",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.floor": {
        "torch_api": "torch.Tensor.floor"
    },
    "paddle.floor_divide": {
        "torch_api": "torch.floor_divide",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.floor_mod": {
        "torch_api": "torch.fmod",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.fmax": {
        "torch_api": "torch.fmax",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.fmin": {
        "torch_api": "torch.fmin",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.frac": {
        "Rule": "FracRule",
        "description": "result = torch.frac(input=x) if x.dtype not in [float16, float32, float64] else result = torch.frac(input=x.to(torch.float64)).to(src_x_dtype), since torch.frac only support float16, float32, float64"
    },
    "paddle.frexp": {
        "torch_api": "torch.frexp",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.frexp": {
        "torch_api": "torch.Tensor.frexp"
    },
    "paddle.full": {
        "Rule": "FullRule"
    },
    "paddle.full_like": {
        "torch_api": "torch.full_like",
        "paddle_torch_args_map": {
            "x": "input",
            "dtype": "dtype"
        },
        "torch_kwargs": {
            "fill_value": "fill_value.item() if isinstance(fill_value, torch.Tensor) else fill_value"
        },
        "description": "result = torch.full_like(input=x, fill_value=torch_kwargs['fill_value'], dtype=dtype)"
    },
    "paddle.gammainc": {
        "torch_api": "torch.special.gammainc",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.gammaincc": {
        "torch_api": "torch.special.gammaincc",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.gammaln": {
        "torch_api": "torch.special.gammaln",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.gather": {
        "Rule": "GatherRule"
    },
    "paddle.Tensor.gather": {
        "Rule": "GatherRule"
    },
    "paddle.gather_nd": {
        "Rule": "Gather_ndRule"
    },
    "paddle.Tensor.gather_nd": {
        "Rule": "Gather_ndRule"
    },
    "paddle.gcd": {
        "torch_api": "torch.gcd",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.gcd": {
        "torch_api": "torch.Tensor.gcd",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.geometric.sample_neighbors": {
        "Rule": "SampleNeighborsRule"
    },
    "paddle.geometric.segment_max": {
        "Rule": "SegmentMaxRule"
    },
    "paddle.geometric.segment_mean": {
        "Rule": "SegmentRule"
    },
    "paddle.geometric.segment_min": {
        "Rule": "SegmentRule"
    },
    "paddle.geometric.segment_sum": {
        "Rule": "SegmentRule"
    },
    "paddle.geometric.send_u_recv": {
        "Rule": "SendURecvRule"
    },
    "paddle.geometric.send_ue_recv": {
        "Rule": "SendUERecvRule"
    },
    "paddle.geometric.send_uv": {
        "Rule": "SendUvRule"
    },
    "paddle.greater_equal": {
        "torch_api": "torch.ge",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        },
        "description": "result = torch.ge(input=x, other=y)"
    },
    "paddle.Tensor.greater_equal": {
        "torch_api": "torch.Tensor.ge",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.ge(other=y)"
    },
    "paddle.greater_than": {
        "torch_api": "torch.gt",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        },
        "description": "result = torch.gt(input=x, other=y)"
    },
    "paddle.Tensor.greater_than": {
        "torch_api": "torch.Tensor.gt",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.gt(other=y)"
    },
    "paddle.heaviside": {
        "torch_api": "torch.heaviside",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "values"
        }
    },
    "paddle.histogram": {
        "torch_api": "torch.histc",
        "paddle_torch_args_map": {
            "input": "input",
            "bins": "bins",
            "min": "min",
            "max": "max"
        }
    },
    "paddle.histogram_bin_edges": {
        "Rule": "HistogramBinEdgeRule"
    },
    "paddle.histogramdd": {
        "Rule": "HistogramddRule"
    },
    "paddle.hsplit": {
        "Rule": "SsplitRule",
        "torch_api": "torch.hsplit",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.hstack": {
        "torch_api": "torch.hstack",
        "paddle_torch_args_map": {
            "x": "tensors"
        }
    },
    "paddle.hypot": {
        "torch_api": "torch.hypot",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.i0": {
        "torch_api": "torch.special.i0",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.i0e": {
        "torch_api": "torch.special.i0e",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.i1": {
        "torch_api": "torch.special.i1",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.i1e": {
        "torch_api": "torch.special.i1e",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.imag": {
        "torch_api": "torch.imag",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.imag": {
        "torch_api": "torch.Tensor.imag",
        "is_attribute": true
    },
    "paddle.increment": {
        "Rule": "IncrementRule"
    },
    "paddle.incubate.nn.functional.blha_get_max_len": {
        "Rule": "BlhaGetMaxLenRule"
    },
    "paddle.incubate.nn.functional.fused_bias_act": {
        "Rule": "FusedBiasActRule"
    },
    "paddle.incubate.nn.functional.fused_bias_dropout_residual_layer_norm": {
        "Rule": "FusedBiasDropoutResidualLayerNormRule"
    },
    "paddle.incubate.nn.functional.fused_dropout_add": {
        "Rule": "FusedDropoutAddRule"
    },
    "paddle.incubate.nn.functional.fused_feedforward": {
        "Rule": "FusedFeedforwardRule"
    },
    "paddle.incubate.nn.functional.fused_layer_norm": {
        "Rule": "FusedLayerNormRule"
    },
    "paddle.incubate.nn.functional.fused_linear": {
        "Rule": "FusedLinearRule"
    },
    "paddle.incubate.nn.functional.fused_linear_activation": {
        "Rule": "FusedLinearActivationRule"
    },
    "paddle.incubate.nn.functional.fused_matmul_bias": {
        "Rule": "FusedMatmulBiasRule"
    },
    "paddle.incubate.nn.functional.fused_multi_head_attention": {
        "Rule": "FusedMultiHeadAttentionRule"
    },
    "paddle.incubate.nn.functional.fused_rms_norm": {
        "Rule": "FusedRMSNormRule"
    },
    "paddle.incubate.nn.functional.fused_rotary_position_embedding": {
        "Rule": "FusedRotaryPositionEmbeddingRule"
    },
    "paddle.incubate.nn.functional.masked_multihead_attention": {
        "Rule": "MaskedMultiheadAttentionRule"
    },
    "paddle.incubate.nn.functional.swiglu": {
        "Rule": "SwigluRule"
    },
    "paddle.incubate.nn.functional.variable_length_memory_efficient_attention": {
        "Rule": "VariableLengthMemoryEfficientAttentionRule"
    },
    "paddle.incubate.segment_max": {
        "Rule": "SegmentRule"
    },
    "paddle.incubate.segment_mean": {
        "Rule": "SegmentRule"
    },
    "paddle.incubate.segment_min": {
        "Rule": "SegmentRule"
    },
    "paddle.incubate.segment_sum": {
        "Rule": "SegmentRule"
    },
    "paddle.incubate.softmax_mask_fuse": {
        "Rule": "SoftmaxMaskFuseRule"
    },
    "paddle.incubate.softmax_mask_fuse_upper_triangle": {
        "Rule": "SoftmaxMaskFuseUpperTriangleRule"
    },
    "paddle.index_add": {
        "Rule": "IndexAddRule"
    },
    "paddle.index_fill": {
        "torch_api": "torch.index_fill",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "value": "value"
        },
        "torch_kwargs": {
            "index": "index.to(torch.int64) if index.dtype != torch.int64 else index"
        }
    },
    "paddle.index_put": {
        "Rule": "IndexPutRule",
        "set_defaults": {
            "accumulate": "False"
        },
        "paddle_torch_args_map": {
            "indices": "indices",
            "accumulate": "accumulate",
            "value": "values"
        }
    },
    "paddle.index_sample": {
        "Rule": "IndexSampleRule"
    },
    "paddle.index_select": {
        "Rule": "IndexSelectRule"
    },
    "paddle.Tensor.index_select": {
        "Rule": "IndexSelectRule"
    },
    "paddle.inner": {
        "torch_api": "torch.inner",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.inner": {
        "torch_api": "torch.Tensor.inner",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.is_complex": {
        "torch_api": "torch.is_complex",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.is_complex": {
        "torch_api": "torch.Tensor.is_complex"
    },
    "paddle.is_empty": {
        "Rule": "IsEmptyRule"
    },
    "paddle.isclose": {
        "torch_api": "torch.isclose",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other",
            "rtol": "rtol",
            "atol": "atol",
            "equal_nan": "equal_nan"
        }
    },
    "paddle.Tensor.isclose": {
        "torch_api": "torch.Tensor.isclose",
        "paddle_torch_args_map": {
            "y": "other",
            "rtol": "rtol",
            "atol": "atol",
            "equal_nan": "equal_nan"
        }
    },
    "paddle.isfinite": {
        "torch_api": "torch.isfinite",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.isin": {
        "torch_api": "torch.isin",
        "paddle_torch_args_map": {
            "x": "elements",
            "test_x": "test_elements",
            "assume_unique": "assume_unique",
            "invert": "invert"
        }
    },
    "paddle.isinf": {
        "torch_api": "torch.isinf",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.isinf": {
        "torch_api": "torch.Tensor.isinf"
    },
    "paddle.isnan": {
        "torch_api": "torch.isnan",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.isnan": {
        "torch_api": "torch.Tensor.isnan"
    },
    "paddle.isneginf": {
        "torch_api": "torch.isneginf",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.isposinf": {
        "torch_api": "torch.isposinf",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.isreal": {
        "torch_api": "torch.isreal",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.kron": {
        "torch_api": "torch.kron",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.kthvalue": {
        "torch_api": "torch.kthvalue",
        "paddle_torch_args_map": {
            "x": "input",
            "k": "k",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.kthvalue": {
        "torch_api": "torch.Tensor.kthvalue",
        "paddle_torch_args_map": {
            "k": "k",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.lcm": {
        "Rule": "LcmRule"
    },
    "paddle.ldexp": {
        "torch_api": "torch.ldexp",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.lerp": {
        "torch_api": "torch.lerp",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "end",
            "weight": "weight"
        }
    },
    "paddle.Tensor.lerp": {
        "torch_api": "torch.Tensor.lerp",
        "paddle_torch_args_map": {
            "y": "end",
            "weight": "weight"
        }
    },
    "paddle.less": {
        "torch_api": "torch.lt",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        },
        "description": "result = torch.lt(input=x, other=y)"
    },
    "paddle.Tensor.less": {
        "torch_api": "torch.Tensor.less",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.less_equal": {
        "torch_api": "torch.le",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        },
        "description": "result = torch.le(input=x, other=y)"
    },
    "paddle.Tensor.less_equal": {
        "torch_api": "torch.Tensor.le",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = x.le(other=y)"
    },
    "paddle.less_than": {
        "torch_api": "torch.lt",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        },
        "description": "result = torch.lt(input=x, other=y)"
    },
    "paddle.Tensor.less_than": {
        "torch_api": "torch.Tensor.lt",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = x.lt(other=y)"
    },
    "paddle.lgamma": {
        "torch_api": "torch.lgamma",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.lgamma": {
        "torch_api": "torch.Tensor.lgamma"
    },
    "paddle.linalg.cholesky": {
        "torch_api": "torch.linalg.cholesky",
        "paddle_torch_args_map": {
            "x": "input",
            "upper": "upper"
        }
    },
    "paddle.linalg.cholesky_solve": {
        "torch_api": "torch.cholesky_solve",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "input2",
            "upper": "upper"
        }
    },
    "paddle.linalg.cond": {
        "torch_api": "torch.linalg.cond",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p"
        }
    },
    "paddle.linalg.corrcoef": {
        "Rule": "CorrcoefRule"
    },
    "paddle.linalg.cov": {
        "Rule": "CovRule",
        "torch_api": "torch.cov",
        "set_defaults": {
            "ddof": "True",
            "fweights": "None",
            "aweights": "None",
            "rowvar": "True"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "fweights": "fweights"
        },
        "torch_kwargs": {
            "correction": "int(ddof)",
            "aweights": "aweights.to(torch.float) if torch.is_tensor(aweights) else aweights"
        }
    },
    "paddle.linalg.det": {
        "torch_api": "torch.linalg.det",
        "paddle_torch_args_map": {
            "x": "A"
        }
    },
    "paddle.linalg.eig": {
        "torch_api": "torch.linalg.eig",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.linalg.eigh": {
        "torch_api": "torch.linalg.eigh",
        "paddle_torch_args_map": {
            "x": "input",
            "UPLO": "UPLO"
        }
    },
    "paddle.linalg.eigvals": {
        "torch_api": "torch.linalg.eigvals",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.linalg.eigvalsh": {
        "torch_api": "torch.linalg.eigvalsh",
        "paddle_torch_args_map": {
            "x": "input",
            "UPLO": "UPLO"
        }
    },
    "paddle.linalg.inv": {
        "torch_api": "torch.linalg.inv",
        "paddle_torch_args_map": {
            "x": "A"
        }
    },
    "paddle.linalg.lstsq": {
        "Rule": "LstsqRule",
        "torch_api": "torch.linalg.lstsq",
        "set_defaults": {
            "rcond": "None",
            "driver": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "y": "b",
            "rcond": "rcond",
            "driver": "driver"
        }
    },
    "paddle.linalg.lu": {
        "torch_api": "torch.lu",
        "paddle_torch_args_map": {
            "x": "A",
            "pivot": "pivot",
            "get_infos": "get_infos"
        }
    },
    "paddle.linalg.lu_unpack": {
        "torch_api": "torch.lu_unpack",
        "paddle_torch_args_map": {
            "x": "LU_data",
            "y": "LU_pivots",
            "unpack_data": "unpack_ludata",
            "unpack_pivots": "unpack_pivots"
        }
    },
    "paddle.linalg.matrix_norm": {
        "torch_api": "torch.linalg.matrix_norm",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "ord",
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.linalg.matrix_power": {
        "torch_api": "torch.linalg.matrix_power",
        "paddle_torch_args_map": {
            "x": "input",
            "n": "n"
        }
    },
    "paddle.linalg.matrix_rank": {
        "Rule": "MatrixRankRule",
        "torch_api": "torch.linalg.matrix_rank",
        "set_defaults": {
            "tol": "None",
            "hermitian": "False",
            "atol": "None",
            "rtol": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "tol": "tol",
            "hermitian": "hermitian",
            "atol": "atol",
            "rtol": "rtol"
        }
    },
    "paddle.linalg.matrix_transpose": {
        "Rule": "Matrix_transposeRule"
    },
    "paddle.linalg.multi_dot": {
        "torch_api": "torch.linalg.multi_dot",
        "paddle_torch_args_map": {
            "x": "tensors"
        }
    },
    "paddle.linalg.norm": {
        "Rule": "NormRule",
        "torch_api": "torch.linalg.norm",
        "set_defaults": {
            "p": "None",
            "axis": "None",
            "keepdim": "False",
            "name": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "p": "ord",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.linalg.pca_lowrank": {
        "torch_api": "torch.pca_lowrank",
        "paddle_torch_args_map": {
            "x": "A",
            "q": "q",
            "center": "center",
            "niter": "niter"
        }
    },
    "paddle.linalg.pinv": {
        "torch_api": "torch.linalg.pinv",
        "paddle_torch_args_map": {
            "x": "input",
            "rcond": "rtol",
            "hermitian": "hermitian"
        }
    },
    "paddle.linalg.qr": {
        "Rule": "QrRule"
    },
    "paddle.linalg.slogdet": {
        "Rule": "SlogdetRule"
    },
    "paddle.linalg.solve": {
        "torch_api": "torch.linalg.solve",
        "paddle_torch_args_map": {
            "x": "A",
            "y": "B",
            "left": "left"
        }
    },
    "paddle.linalg.svd": {
        "torch_api": "torch.linalg.svd",
        "paddle_torch_args_map": {
            "x": "A",
            "full_matrices": "full_matrices"
        }
    },
    "paddle.linalg.svd_lowrank": {
        "torch_api": "torch.svd_lowrank",
        "paddle_torch_args_map": {
            "x": "A",
            "q": "q",
            "niter": "niter",
            "M": "M"
        }
    },
    "paddle.linalg.svdvals": {
        "torch_api": "torch.linalg.svdvals",
        "paddle_torch_args_map": {
            "x": "A"
        }
    },
    "paddle.linalg.triangular_solve": {
        "Rule": "TriangularSolveRule"
    },
    "paddle.linalg.vector_norm": {
        "torch_api": "torch.linalg.vector_norm",
        "paddle_torch_args_map": {
            "x": "x",
            "p": "ord",
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.linspace": {
        "torch_api": "torch.linspace",
        "paddle_torch_args_map": {
            "dtype": "dtype"
        },
        "torch_kwargs": {
            "start": "start.reshape([]) if isinstance(start, torch.Tensor) else start",
            "end": "stop.reshape([]) if isinstance(stop, torch.Tensor) else stop",
            "steps": "int(num) if isinstance(num, (float, torch.Tensor)) else num"
        },
        "description": "result = torch.linspace(start=torch_kwargs['start'], end=torch_kwargs['end'], steps=torch_kwargs['step'], dtype=dtype)"
    },
    "paddle.log": {
        "torch_api": "torch.log",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.log": {
        "torch_api": "torch.Tensor.log"
    },
    "paddle.log10": {
        "torch_api": "torch.log10",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.log10": {
        "torch_api": "torch.Tensor.log10"
    },
    "paddle.log1p": {
        "torch_api": "torch.log1p",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.log1p": {
        "torch_api": "torch.Tensor.log1p"
    },
    "paddle.log2": {
        "torch_api": "torch.log2",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.log_normal": {
        "Rule": "LogNormalRule",
        "torch_api": "torch.normal",
        "set_defaults": {
            "mean": 1.0,
            "std": 2.0
        },
        "paddle_torch_args_map": {
            "mean": "mean",
            "std": "std",
            "shape": "size"
        }
    },
    "paddle.logaddexp": {
        "Rule": "LogaddexpRule",
        "torch_api": "torch.logaddexp",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.logcumsumexp": {
        "Rule": "LogcumsumexpRule",
        "description": "result = torch.logcumsumexp(input=x, dim=axis)"
    },
    "paddle.logical_and": {
        "torch_api": "torch.logical_and",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.logical_and": {
        "torch_api": "torch.Tensor.logical_and",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.logical_not": {
        "torch_api": "torch.logical_not",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.logical_not": {
        "torch_api": "torch.Tensor.logical_not"
    },
    "paddle.logical_or": {
        "torch_api": "torch.logical_or",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.logical_or": {
        "torch_api": "torch.Tensor.logical_or",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.logical_xor": {
        "torch_api": "torch.logical_xor",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.logit": {
        "torch_api": "torch.special.logit",
        "paddle_torch_args_map": {
            "x": "input",
            "eps": "eps"
        }
    },
    "paddle.Tensor.logit": {
        "torch_api": "torch.Tensor.logit",
        "paddle_torch_args_map": {
            "eps": "eps"
        }
    },
    "paddle.logspace": {
        "torch_api": "torch.logspace",
        "set_defaults": {
            "base": 10.0
        },
        "paddle_torch_args_map": {
            "dtype": "dtype"
        },
        "torch_kwargs": {
            "start": "start.reshape([]) if isinstance(start, torch.Tensor) else start",
            "end": "stop.reshape([]) if isinstance(stop, torch.Tensor) else stop",
            "steps": "int(num.item()) if isinstance(num, torch.Tensor) else int(num)",
            "base": "float(base.item()) if isinstance(base, torch.Tensor) else float(base)"
        },
        "description": "result = torch.logspace(start=start, end=stop, steps=num, base=base, dtype=dtype)"
    },
    "paddle.logsumexp": {
        "torch_api": "torch.logsumexp",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "keepdim": "keepdim"
        },
        "torch_kwargs": {
            "dim": "tuple(range(x.dim())) if axis is None else axis"
        }
    },
    "paddle.Tensor.logsumexp": {
        "torch_api": "torch.Tensor.logsumexp",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False"
        },
        "paddle_torch_args_map": {
            "keepdim": "keepdim"
        },
        "torch_kwargs": {
            "dim": "tuple(range(x.dim())) if axis is None else axis"
        }
    },
    "paddle.masked_fill": {
        "torch_api": "torch.masked_fill",
        "paddle_torch_args_map": {
            "x": "input",
            "mask": "mask"
        },
        "torch_kwargs": {
            "value": "value.squeeze() if torch.is_tensor(value) and value.ndim == 1 else value"
        }
    },
    "paddle.Tensor.masked_fill": {
        "torch_api": "torch.Tensor.masked_fill",
        "paddle_torch_args_map": {
            "mask": "mask",
            "value": "value"
        }
    },
    "paddle.masked_scatter": {
        "Rule": "MaskedScatterRule",
        "torch_api": "torch.Tensor.masked_scatter",
        "paddle_torch_args_map": {
            "mask": "mask",
            "value": "source"
        }
    },
    "paddle.Tensor.masked_scatter": {
        "Rule": "MaskedScatterRule",
        "torch_api": "torch.Tensor.masked_scatter",
        "paddle_torch_args_map": {
            "mask": "mask",
            "value": "source"
        }
    },
    "paddle.masked_select": {
        "torch_api": "torch.masked_select",
        "paddle_torch_args_map": {
            "x": "input",
            "mask": "mask"
        }
    },
    "paddle.Tensor.masked_select": {
        "torch_api": "torch.Tensor.masked_select",
        "paddle_torch_args_map": {
            "mask": "mask"
        }
    },
    "paddle.matmul": {
        "Rule": "MatmulRule",
        "torch_api": "torch.matmul",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.matmul": {
        "Rule": "MatmulTensorRule",
        "torch_api": "torch.Tensor.matmul",
        "set_defaults": {
            "transpose_x": "False",
            "transpose_y": "False"
        },
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.matrix_transpose": {
        "Rule": "Matrix_transposeRule"
    },
    "paddle.max": {
        "Rule": "ReduceRule",
        "torch_api": "torch.amax",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False"
        }
    },
    "paddle.Tensor.max": {
        "torch_api": "torch.Tensor.max",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.maximum": {
        "torch_api": "torch.maximum",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.mean": {
        "Rule": "ReduceRule",
        "torch_api": "torch.mean",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False"
        }
    },
    "paddle.Tensor.mean": {
        "Rule": "ReduceRule",
        "torch_api": "torch.Tensor.mean",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False"
        }
    },
    "paddle.median": {
        "Rule": "MedianRule"
    },
    "paddle.Tensor.median": {
        "Rule": "MedianRule",
        "torch_api": "torch.Tensor.median"
    },
    "paddle.meshgrid": {
        "torch_api": "torch.meshgrid",
        "torch_args": [
            "*args"
        ]
    },
    "paddle.min": {
        "Rule": "ReduceRule",
        "torch_api": "torch.amin",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False"
        }
    },
    "paddle.Tensor.min": {
        "torch_api": "torch.Tensor.min",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.minimum": {
        "torch_api": "torch.minimum",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.mm": {
        "Rule": "MmRule",
        "torch_api": "torch.matmul",
        "paddle_torch_args_map": {
            "input": "input",
            "mat2": "other"
        }
    },
    "paddle.Tensor.mm": {
        "torch_api": "torch.Tensor.mm",
        "paddle_torch_args_map": {
            "mat2": "mat2"
        }
    },
    "paddle.mod": {
        "torch_api": "torch.fmod",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.mod": {
        "torch_api": "torch.Tensor.fmod",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.mode": {
        "torch_api": "torch.mode",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.mode": {
        "torch_api": "torch.Tensor.mode",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.moveaxis": {
        "torch_api": "torch.moveaxis",
        "paddle_torch_args_map": {
            "x": "input",
            "source": "source",
            "destination": "destination"
        }
    },
    "paddle.Tensor.moveaxis": {
        "torch_api": "torch.Tensor.moveaxis",
        "paddle_torch_args_map": {
            "source": "source",
            "destination": "destination"
        }
    },
    "paddle.multigammaln": {
        "torch_api": "torch.mvlgamma",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p"
        }
    },
    "paddle.Tensor.multigammaln": {
        "torch_api": "torch.Tensor.mvlgamma",
        "paddle_torch_args_map": {
            "p": "p"
        }
    },
    "paddle.multinomial": {
        "torch_api": "torch.multinomial",
        "paddle_torch_args_map": {
            "x": "input",
            "num_samples": "num_samples",
            "replacement": "replacement"
        }
    },
    "paddle.multiplex": {
        "Rule": "MultiplexRule"
    },
    "paddle.multiply": {
        "torch_api": "torch.mul",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.multiply": {
        "torch_api": "torch.Tensor.mul",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.mv": {
        "torch_api": "torch.mv",
        "paddle_torch_args_map": {
            "x": "input",
            "vec": "vec"
        }
    },
    "paddle.nan_to_num": {
        "torch_api": "torch.nan_to_num",
        "paddle_torch_args_map": {
            "x": "input",
            "nan": "nan",
            "posinf": "posinf",
            "neginf": "neginf"
        }
    },
    "paddle.nanmean": {
        "torch_api": "torch.nanmean",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.nanmedian": {
        "Rule": "NanmedianRule"
    },
    "paddle.nanquantile": {
        "Rule": "QuantileRule",
        "torch_api": "torch.nanquantile",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False",
            "interpolation": "'linear'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "q": "q",
            "axis": "dim",
            "keepdim": "keepdim",
            "interpolation": "interpolation"
        }
    },
    "paddle.nansum": {
        "torch_api": "torch.nansum",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.Tensor.nansum": {
        "torch_api": "torch.Tensor.nansum",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.neg": {
        "torch_api": "torch.neg",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.neg": {
        "torch_api": "torch.Tensor.neg"
    },
    "paddle.negative": {
        "torch_api": "torch.negative",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nextafter": {
        "torch_api": "torch.nextafter",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.nn.functional.adaptive_avg_pool1d": {
        "torch_api": "torch.nn.functional.adaptive_avg_pool1d",
        "paddle_torch_args_map": {
            "x": "input",
            "output_size": "output_size"
        }
    },
    "paddle.nn.functional.adaptive_avg_pool2d": {
        "Rule": "AdaptiveAvgPoolRule",
        "torch_api": "torch.nn.functional.adaptive_avg_pool2d",
        "set_defaults": {
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "output_size": "output_size"
        }
    },
    "paddle.nn.functional.adaptive_avg_pool3d": {
        "Rule": "AdaptiveAvgPoolRule",
        "torch_api": "torch.nn.functional.adaptive_avg_pool3d",
        "set_defaults": {
            "data_format": "'NCDHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "output_size": "output_size"
        }
    },
    "paddle.nn.functional.adaptive_log_softmax_with_loss": {
        "Rule": "Adaptive_log_softmax_with_lossRule"
    },
    "paddle.nn.functional.adaptive_max_pool1d": {
        "torch_api": "torch.nn.functional.adaptive_max_pool1d",
        "paddle_torch_args_map": {
            "x": "input",
            "output_size": "output_size",
            "return_mask": "return_indices"
        }
    },
    "paddle.nn.functional.adaptive_max_pool2d": {
        "torch_api": "torch.nn.functional.adaptive_max_pool2d",
        "paddle_torch_args_map": {
            "x": "input",
            "output_size": "output_size",
            "return_mask": "return_indices"
        }
    },
    "paddle.nn.functional.adaptive_max_pool3d": {
        "torch_api": "torch.nn.functional.adaptive_max_pool3d",
        "paddle_torch_args_map": {
            "x": "input",
            "output_size": "output_size",
            "return_mask": "return_indices"
        }
    },
    "paddle.nn.functional.affine_grid": {
        "torch_api": "torch.nn.functional.affine_grid",
        "paddle_torch_args_map": {
            "theta": "theta",
            "align_corners": "align_corners"
        },
        "torch_kwargs": {
            "size": "tuple(out_shape.tolist()) if torch.is_tensor(out_shape) else out_shape"
        }
    },
    "paddle.nn.functional.alpha_dropout": {
        "torch_api": "torch.nn.functional.alpha_dropout",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p",
            "training": "training",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.avg_pool1d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.avg_pool1d",
        "set_defaults": {
            "padding": 0,
            "stride": "None",
            "exclusive": false
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "ceil_mode": "ceil_mode"
        },
        "torch_kwargs": {
            "count_include_pad": "not exclusive"
        }
    },
    "paddle.nn.functional.avg_pool2d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.avg_pool2d",
        "set_defaults": {
            "padding": 0,
            "stride": "None",
            "exclusive": false,
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "ceil_mode": "ceil_mode",
            "divisor_override": "divisor_override"
        },
        "torch_kwargs": {
            "count_include_pad": "not exclusive"
        }
    },
    "paddle.nn.functional.avg_pool3d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.avg_pool3d",
        "set_defaults": {
            "padding": 0,
            "stride": "None",
            "exclusive": false,
            "data_format": "'NCDHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "ceil_mode": "ceil_mode",
            "divisor_override": "divisor_override"
        },
        "torch_kwargs": {
            "count_include_pad": "not exclusive"
        }
    },
    "paddle.nn.functional.batch_norm": {
        "Rule": "BatchNormRule",
        "torch_api": "torch.nn.functional.batch_norm",
        "set_defaults": {
            "training": false,
            "momentum": 0.9,
            "use_global_stats": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "running_mean": "running_mean",
            "running_var": "running_var",
            "weight": "weight",
            "bias": "bias",
            "epsilon": "eps"
        },
        "torch_kwargs": {
            "momentum": "1 - momentum",
            "training": "training if use_global_stats is None else not use_global_stats"
        }
    },
    "paddle.nn.functional.bilinear": {
        "torch_api": "torch.nn.functional.bilinear",
        "paddle_torch_args_map": {
            "x1": "input1",
            "x2": "input2",
            "weight": "weight"
        },
        "torch_kwargs": {
            "bias": "bias.squeeze(0) if 'bias' in locals() else None"
        }
    },
    "paddle.nn.functional.binary_cross_entropy": {
        "Rule": "WeightDetachRule",
        "torch_api": "torch.nn.functional.binary_cross_entropy",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "weight": "weight",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.binary_cross_entropy_with_logits": {
        "Rule": "WeightDetachRule",
        "torch_api": "torch.nn.functional.binary_cross_entropy_with_logits",
        "paddle_torch_args_map": {
            "logit": "input",
            "label": "target",
            "weight": "weight",
            "reduction": "reduction",
            "pos_weight": "pos_weight"
        }
    },
    "paddle.nn.functional.celu": {
        "torch_api": "torch.nn.functional.celu",
        "paddle_torch_args_map": {
            "x": "input",
            "alpha": "alpha",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.channel_shuffle": {
        "Rule": "DataFormatRule",
        "torch_api": "torch.nn.functional.channel_shuffle",
        "paddle_torch_args_map": {
            "x": "input",
            "groups": "groups"
        }
    },
    "paddle.nn.functional.class_center_sample": {
        "Rule": "ClassCenterSampleRule"
    },
    "paddle.nn.functional.conv1d": {
        "Rule": "Conv1dRule",
        "torch_api": "torch.nn.functional.conv1d",
        "set_defaults": {
            "bias": "None",
            "stride": 1,
            "padding": 0,
            "dilation": 1,
            "groups": 1,
            "data_format": "'NCL'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "dilation": "dilation",
            "groups": "groups"
        }
    },
    "paddle.nn.functional.conv1d_transpose": {
        "Rule": "Conv1dTransposeRule",
        "torch_api": "torch.nn.functional.conv_transpose1d",
        "set_defaults": {
            "bias": "None",
            "stride": 1,
            "padding": 0,
            "output_padding": 0,
            "groups": 1,
            "dialation": 1,
            "output_size": "None",
            "data_format": "'NCL'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "output_padding": "output_padding",
            "groups": "groups",
            "dilation": "dilation"
        }
    },
    "paddle.nn.functional.conv2d": {
        "Rule": "Conv2dRule",
        "torch_api": "torch.nn.functional.conv2d",
        "set_defaults": {
            "bias": "None",
            "stride": 1,
            "padding": 0,
            "dilation": 1,
            "groups": 1,
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "dilation": "dilation",
            "groups": "groups"
        }
    },
    "paddle.nn.functional.conv2d_transpose": {
        "Rule": "Conv2dTransposeRule",
        "torch_api": "torch.nn.functional.conv_transpose2d",
        "set_defaults": {
            "bias": "None",
            "stride": 1,
            "padding": 0,
            "output_padding": 0,
            "groups": 1,
            "dilation": 1,
            "output_size": "None",
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "output_padding": "output_padding",
            "groups": "groups",
            "dilation": "dilation"
        }
    },
    "paddle.nn.functional.conv3d": {
        "Rule": "Conv3dRule",
        "torch_api": "torch.nn.functional.conv3d",
        "set_defaults": {
            "bias": "None",
            "stride": 1,
            "padding": 0,
            "dilation": 1,
            "groups": 1,
            "data_format": "'NCDHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "dilation": "dilation",
            "groups": "groups"
        }
    },
    "paddle.nn.functional.conv3d_transpose": {
        "Rule": "Conv3dTransposeRule",
        "torch_api": "torch.nn.functional.conv_transpose3d",
        "set_defaults": {
            "bias": "None",
            "stride": 1,
            "padding": 0,
            "output_padding": 0,
            "groups": 1,
            "dialation": 1,
            "output_size": "None",
            "data_format": "'NCDHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "output_padding": "output_padding",
            "groups": "groups",
            "dilation": "dilation"
        }
    },
    "paddle.nn.functional.cosine_embedding_loss": {
        "Rule": "CosineEmbeddingLossRule",
        "torch_api": "torch.nn.functional.cosine_embedding_loss",
        "paddle_torch_args_map": {
            "input1": "input1",
            "input2": "input2",
            "label": "target",
            "margin": "margin",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.cosine_similarity": {
        "torch_api": "torch.nn.functional.cosine_similarity",
        "paddle_torch_args_map": {
            "x1": "x1",
            "x2": "x2",
            "axis": "dim",
            "eps": "eps"
        }
    },
    "paddle.nn.functional.cross_entropy": {
        "Rule": "CrossEntropyRule",
        "torch_api": "torch.nn.functional.cross_entropy",
        "set_defaults": {
            "weight": "None",
            "reduction": "'mean'",
            "soft_label": "False",
            "label_smoothing": "0.0",
            "reduction_original": "None"
        },
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "weight": "weight",
            "reduction": "reduction",
            "ignore_index": "ignore_index",
            "label_smoothing": "label_smoothing"
        }
    },
    "paddle.nn.functional.ctc_loss": {
        "Rule": "CtcLossRule"
    },
    "paddle.nn.functional.dice_loss": {
        "Rule": "DiceLossRule"
    },
    "paddle.nn.functional.dropout": {
        "Rule": "DropoutRule"
    },
    "paddle.nn.functional.dropout2d": {
        "Rule": "Dropout2dRule"
    },
    "paddle.nn.functional.dropout3d": {
        "Rule": "Dropout3dRule"
    },
    "paddle.nn.functional.elu": {
        "torch_api": "torch.nn.functional.elu",
        "paddle_torch_args_map": {
            "x": "input",
            "alpha": "alpha",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.embedding": {
        "Rule": "EembeddingRule"
    },
    "paddle.nn.functional.feature_alpha_dropout": {
        "torch_api": "torch.nn.functional.feature_alpha_dropout",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p",
            "training": "training"
        }
    },
    "paddle.nn.functional.fold": {
        "torch_api": "torch.nn.functional.fold",
        "set_defaults": {
            "strides": 1,
            "paddings": 0,
            "dilations": 1
        },
        "paddle_torch_args_map": {
            "x": "input",
            "output_sizes": "output_size",
            "kernel_sizes": "kernel_size",
            "strides": "stride",
            "dilations": "dilation"
        },
        "torch_kwargs": {
            "padding": "(paddings[0], paddings[2]) if isinstance(paddings, list) and len(paddings) == 4 else paddings"
        }
    },
    "paddle.nn.functional.fractional_max_pool2d": {
        "Rule": "FractionalMaxPoolRule",
        "torch_api": "torch.nn.functional.fractional_max_pool2d",
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "output_size": "output_size",
            "return_mask": "return_indices",
            "_random_samples": "random_u"
        }
    },
    "paddle.nn.functional.fractional_max_pool3d": {
        "Rule": "FractionalMaxPoolRule",
        "torch_api": "torch.nn.functional.fractional_max_pool3d",
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "output_size": "output_size",
            "return_mask": "return_indices",
            "_random_samples": "random_u"
        }
    },
    "paddle.nn.functional.gather_tree": {
        "Rule": "Gather_treeRule"
    },
    "paddle.nn.functional.gaussian_nll_loss": {
        "torch_api": "torch.nn.functional.gaussian_nll_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "variance": "var",
            "full": "full",
            "epsilon": "eps",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.gelu": {
        "torch_api": "torch.nn.functional.gelu",
        "set_defaults": {
            "approximate": false
        },
        "paddle_torch_args_map": {
            "x": "input"
        },
        "torch_kwargs": {
            "approximate": "'tanh' if approximate else 'none'"
        }
    },
    "paddle.nn.functional.glu": {
        "torch_api": "torch.nn.functional.glu",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim"
        }
    },
    "paddle.nn.functional.grid_sample": {
        "torch_api": "torch.nn.functional.grid_sample",
        "set_defaults": {
            "align_corners": "True"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "grid": "grid",
            "mode": "mode",
            "padding_mode": "padding_mode",
            "align_corners": "align_corners"
        }
    },
    "paddle.nn.functional.group_norm": {
        "Rule": "GroupNormRule"
    },
    "paddle.nn.functional.gumbel_softmax": {
        "torch_api": "torch.nn.functional.gumbel_softmax",
        "paddle_torch_args_map": {
            "x": "logits",
            "temperature": "tau",
            "hard": "hard",
            "axis": "dim"
        }
    },
    "paddle.nn.functional.hardshrink": {
        "torch_api": "torch.nn.functional.hardshrink",
        "paddle_torch_args_map": {
            "x": "input",
            "threshold": "lambd"
        }
    },
    "paddle.nn.functional.hardsigmoid": {
        "Rule": "HardsigmoidRule",
        "torch_api": "torch.nn.functional.hardsigmoid",
        "set_defaults": {
            "slope": "0.1666667",
            "offset": "0.5"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.hardswish": {
        "torch_api": "torch.nn.functional.hardswish",
        "paddle_torch_args_map": {
            "x": "input",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.hardtanh": {
        "Rule": "HardtanhRule",
        "torch_api": "torch.nn.functional.hardtanh",
        "set_defaults": {
            "min": "-1.0",
            "max": "1.0"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "min": "min_val",
            "max": "max_val",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.hinge_embedding_loss": {
        "torch_api": "torch.nn.functional.hinge_embedding_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "margin": "margin",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.hsigmoid_loss": {
        "Rule": "HsigmoidLossRule"
    },
    "paddle.nn.functional.instance_norm": {
        "torch_api": "torch.nn.functional.instance_norm",
        "paddle_torch_args_map": {
            "x": "input",
            "running_mean": "running_mean",
            "running_var": "running_var",
            "weight": "weight",
            "bias": "bias",
            "eps": "eps",
            "momentum": "momentum"
        }
    },
    "paddle.nn.functional.interpolate": {
        "Rule": "InterpolateRule",
        "torch_api": "torch.nn.functional.interpolate",
        "set_defaults": {
            "size": "None",
            "scale_factor": "None",
            "data_format": "'NCDHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "size": "size",
            "scale_factor": "scale_factor",
            "mode": "mode",
            "align_corners": "align_corners",
            "recompute_scale_factor": "recompute_scale_factor"
        }
    },
    "paddle.nn.functional.kl_div": {
        "torch_api": "torch.nn.functional.kl_div",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "reduction": "reduction",
            "log_target": "log_target"
        }
    },
    "paddle.nn.functional.l1_loss": {
        "torch_api": "torch.nn.functional.l1_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.label_smooth": {
        "Rule": "LabelSmoothRule"
    },
    "paddle.nn.functional.layer_norm": {
        "Rule": "LayerNormRule",
        "torch_api": "torch.nn.functional.layer_norm",
        "set_defaults": {
            "epsilon": 1e-05,
            "weight": "None",
            "bias": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "normalized_shape": "normalized_shape",
            "weight": "weight",
            "bias": "bias",
            "epsilon": "eps"
        }
    },
    "paddle.nn.functional.leaky_relu": {
        "torch_api": "torch.nn.functional.leaky_relu",
        "paddle_torch_args_map": {
            "x": "input",
            "negative_slope": "negative_slope",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.linear": {
        "Rule": "LinearRule",
        "torch_api": "torch.nn.functional.linear",
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight",
            "bias": "bias"
        }
    },
    "paddle.nn.functional.local_response_norm": {
        "Rule": "LocalResponseNormRule",
        "torch_api": "torch.nn.functional.local_response_norm",
        "paddle_torch_args_map": {
            "x": "input",
            "size": "size",
            "alpha": "alpha",
            "beta": "beta",
            "k": "k"
        }
    },
    "paddle.nn.functional.log_loss": {
        "Rule": "LogLossRule"
    },
    "paddle.nn.functional.log_sigmoid": {
        "torch_api": "torch.nn.functional.logsigmoid",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nn.functional.log_softmax": {
        "Rule": "LogSoftMaxRule",
        "torch_api": "torch.nn.functional.log_softmax",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "dtype": "dtype"
        }
    },
    "paddle.nn.functional.lp_pool1d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.lp_pool1d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCL'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "norm_type": "norm_type",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "ceil_mode": "ceil_mode"
        }
    },
    "paddle.nn.functional.lp_pool2d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.lp_pool2d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "norm_type": "norm_type",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "ceil_mode": "ceil_mode"
        }
    },
    "paddle.nn.functional.margin_cross_entropy": {
        "Rule": "MarginCrossEntropyRule"
    },
    "paddle.nn.functional.margin_ranking_loss": {
        "torch_api": "torch.nn.functional.margin_ranking_loss",
        "paddle_torch_args_map": {
            "input": "input1",
            "other": "input2",
            "margin": "margin",
            "reduction": "reduction"
        },
        "torch_kwargs": {
            "target": "torch.broadcast_to(label, input.shape)"
        }
    },
    "paddle.nn.functional.max_pool1d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.max_pool1d",
        "set_defaults": {
            "stride": "None",
            "padding": 0
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "ceil_mode": "ceil_mode",
            "return_mask": "return_indices"
        }
    },
    "paddle.nn.functional.max_pool2d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.max_pool2d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "ceil_mode": "ceil_mode",
            "return_mask": "return_indices"
        }
    },
    "paddle.nn.functional.max_pool3d": {
        "Rule": "PoolRule",
        "torch_api": "torch.nn.functional.max_pool3d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCDHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "ceil_mode": "ceil_mode",
            "return_mask": "return_indices"
        }
    },
    "paddle.nn.functional.max_unpool1d": {
        "Rule": "UnpoolRule",
        "torch_api": "torch.nn.functional.max_unpool1d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCL'",
            "output_size": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "indices": "indices",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "output_size": "output_size"
        }
    },
    "paddle.nn.functional.max_unpool2d": {
        "Rule": "UnpoolRule",
        "torch_api": "torch.nn.functional.max_unpool2d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCHW'",
            "output_size": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "indices": "indices",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "output_size": "output_size"
        }
    },
    "paddle.nn.functional.max_unpool3d": {
        "Rule": "UnpoolRule",
        "torch_api": "torch.nn.functional.max_unpool3d",
        "set_defaults": {
            "stride": "None",
            "padding": 0,
            "data_format": "'NCDHW'",
            "output_size": "None"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "indices": "indices",
            "kernel_size": "kernel_size",
            "stride": "stride",
            "padding": "padding",
            "output_size": "output_size"
        }
    },
    "paddle.nn.functional.maxout": {
        "Rule": "MaxoutRule"
    },
    "paddle.nn.functional.mish": {
        "torch_api": "torch.nn.functional.mish",
        "paddle_torch_args_map": {
            "x": "input",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.mse_loss": {
        "torch_api": "torch.nn.functional.mse_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.multi_label_soft_margin_loss": {
        "torch_api": "torch.nn.functional.multilabel_soft_margin_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "reduction": "reduction",
            "weight": "weight"
        }
    },
    "paddle.nn.functional.multi_margin_loss": {
        "Rule": "WeightDetachRule",
        "torch_api": "torch.nn.functional.multi_margin_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "margin": "margin",
            "weight": "weight",
            "p": "p",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.nll_loss": {
        "Rule": "WeightDetachRule",
        "torch_api": "torch.nn.functional.nll_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "weight": "weight",
            "reduction": "reduction",
            "ignore_index": "ignore_index"
        }
    },
    "paddle.nn.functional.normalize": {
        "torch_api": "torch.nn.functional.normalize",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p",
            "axis": "dim",
            "epsilon": "eps"
        }
    },
    "paddle.nn.functional.npair_loss": {
        "Rule": "NpairlossRule"
    },
    "paddle.nn.functional.one_hot": {
        "torch_api": "torch.nn.functional.one_hot",
        "paddle_torch_args_map": {
            "x": "input",
            "num_classes": "num_classes"
        }
    },
    "paddle.nn.functional.pad": {
        "Rule": "PadRule",
        "torch_api": "paddle.nn.functional.pad"
    },
    "paddle.nn.functional.pairwise_distance": {
        "torch_api": "torch.nn.functional.pairwise_distance",
        "paddle_torch_args_map": {
            "x": "x1",
            "y": "x2",
            "p": "p",
            "epsilon": "eps",
            "keepdim": "keepdim"
        }
    },
    "paddle.nn.functional.pixel_shuffle": {
        "Rule": "DataFormatRule",
        "torch_api": "torch.nn.functional.pixel_shuffle",
        "set_defaults": {
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "upscale_factor": "upscale_factor"
        }
    },
    "paddle.nn.functional.pixel_unshuffle": {
        "Rule": "DataFormatRule",
        "torch_api": "torch.nn.functional.pixel_unshuffle",
        "set_defaults": {
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "downscale_factor": "downscale_factor"
        }
    },
    "paddle.nn.functional.poisson_nll_loss": {
        "torch_api": "torch.nn.functional.poisson_nll_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "log_input": "log_input",
            "full": "full",
            "epsilon": "eps",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.prelu": {
        "Rule": "DataFormatRule",
        "torch_api": "torch.nn.functional.prelu",
        "set_defaults": {
            "data_format": "'NCHW'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "weight": "weight"
        }
    },
    "paddle.nn.functional.relu": {
        "torch_api": "torch.nn.functional.relu",
        "paddle_torch_args_map": {
            "x": "input",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.relu6": {
        "torch_api": "torch.nn.functional.relu6",
        "paddle_torch_args_map": {
            "x": "input",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.rnnt_loss": {
        "Rule": "RnntLossRule"
    },
    "paddle.nn.functional.rrelu": {
        "torch_api": "torch.nn.functional.rrelu",
        "paddle_torch_args_map": {
            "x": "input",
            "lower": "lower",
            "upper": "upper",
            "training": "training",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.scaled_dot_product_attention": {
        "Rule": "ScaledDotProductAttentionRule",
        "torch_api": "torch.nn.functional.scaled_dot_product_attention",
        "set_defaults": {
            "attn_mask": "None",
            "dropout_p": 0,
            "is_causal": false
        },
        "paddle_torch_args_map": {
            "query": "query",
            "key": "key",
            "value": "value",
            "attn_mask": "attn_mask",
            "dropout_p": "dropout_p",
            "is_causal": "is_causal"
        }
    },
    "paddle.nn.functional.selu": {
        "Rule": "SeluRule",
        "torch_api": "torch.nn.functional.selu",
        "set_defaults": {
            "scale": "1.0507009873554804934193349852946",
            "alpha": "1.6732632423543772848170429916717"
        },
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nn.functional.sequence_mask": {
        "Rule": "SquenceMaskRule"
    },
    "paddle.nn.functional.sigmoid": {
        "torch_api": "torch.nn.functional.sigmoid",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nn.functional.sigmoid_focal_loss": {
        "Rule": "SigmoidFocalLossRule"
    },
    "paddle.nn.functional.silu": {
        "torch_api": "torch.nn.functional.silu",
        "paddle_torch_args_map": {
            "x": "input",
            "inplace": "inplace"
        }
    },
    "paddle.nn.functional.smooth_l1_loss": {
        "torch_api": "torch.nn.functional.huber_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "reduction": "reduction",
            "delta": "delta"
        }
    },
    "paddle.nn.functional.soft_margin_loss": {
        "Rule": "SoftMarginLossRule",
        "torch_api": "torch.nn.functional.soft_margin_loss",
        "paddle_torch_args_map": {
            "input": "input",
            "label": "target",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.softmax": {
        "Rule": "SoftMaxRule",
        "torch_api": "torch.nn.functional.softmax",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "dtype": "dtype"
        }
    },
    "paddle.nn.functional.softmax_with_cross_entropy": {
        "Rule": "SoftmaxWithCrossEntropyRule"
    },
    "paddle.nn.functional.softplus": {
        "torch_api": "torch.nn.functional.softplus",
        "paddle_torch_args_map": {
            "x": "input",
            "beta": "beta",
            "threshold": "threshold"
        }
    },
    "paddle.nn.functional.softshrink": {
        "torch_api": "torch.nn.functional.softshrink",
        "paddle_torch_args_map": {
            "x": "input",
            "threshold": "lambd"
        }
    },
    "paddle.nn.functional.softsign": {
        "torch_api": "torch.nn.functional.softsign",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nn.functional.square_error_cost": {
        "Rule": "SquareErrorCostRule"
    },
    "paddle.nn.functional.swish": {
        "Rule": "SwishRule"
    },
    "paddle.nn.functional.tanh": {
        "torch_api": "torch.nn.functional.tanh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nn.functional.tanhshrink": {
        "torch_api": "torch.nn.functional.tanhshrink",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.nn.functional.temporal_shift": {
        "Rule": "TemporalShiftRule"
    },
    "paddle.nn.functional.thresholded_relu": {
        "torch_api": "torch.nn.functional.threshold",
        "set_defaults": {
            "threshold": 1.0,
            "value": 0.0
        },
        "paddle_torch_args_map": {
            "x": "input",
            "threshold": "threshold",
            "value": "value"
        }
    },
    "paddle.nn.functional.triplet_margin_with_distance_loss": {
        "torch_api": "torch.nn.functional.triplet_margin_with_distance_loss",
        "paddle_torch_args_map": {
            "input": "anchor",
            "positive": "positive",
            "negative": "negative",
            "distance_function": "distance_function",
            "margin": "margin",
            "swap": "swap",
            "reduction": "reduction"
        }
    },
    "paddle.nn.functional.unfold": {
        "torch_api": "torch.nn.functional.unfold",
        "set_defaults": {
            "strides": 1,
            "paddings": 0,
            "dilations": 1
        },
        "paddle_torch_args_map": {
            "x": "input",
            "kernel_sizes": "kernel_size",
            "dilations": "dilation",
            "strides": "stride"
        },
        "torch_kwargs": {
            "padding": "(paddings[0], paddings[2]) if isinstance(paddings, list) and len(paddings) == 4 else paddings"
        }
    },
    "paddle.nn.functional.upsample": {
        "Rule": "UpsampleRule",
        "torch_api": "torch.nn.functional.upsample",
        "paddle_torch_args_map": {
            "x": "input",
            "size": "size",
            "scale_factor": "scale_factor",
            "mode": "mode",
            "align_corners": "align_corners"
        }
    },
    "paddle.nn.functional.zeropad2d": {
        "Rule": "Zeropad2dRule"
    },
    "paddle.nn.quant.weight_only_linear": {
        "Rule": "WeightOnlyLinearRule"
    },
    "paddle.nn.utils.parameters_to_vector": {
        "torch_api": "torch.nn.utils.parameters_to_vector",
        "paddle_torch_args_map": {
            "parameters": "parameters"
        }
    },
    "paddle.nn.utils.vector_to_parameters": {
        "torch_api": "torch.nn.utils.vector_to_parameters",
        "paddle_torch_args_map": {
            "vec": "vec",
            "parameters": "parameters"
        }
    },
    "paddle.nonzero": {
        "torch_api": "torch.nonzero",
        "set_defaults": {
            "as_tuple": "False"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "as_tuple": "as_tuple"
        }
    },
    "paddle.Tensor.nonzero": {
        "torch_api": "torch.Tensor.nonzero",
        "paddle_torch_args_map": {
            "as_tuple": "as_tuple"
        }
    },
    "paddle.normal": {
        "Rule": "NormalRule"
    },
    "paddle.not_equal": {
        "torch_api": "torch.ne",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.not_equal": {
        "torch_api": "torch.Tensor.not_equal",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.numel": {
        "Rule": "NumelRule"
    },
    "paddle.ones": {
        "Rule": "OnesRule"
    },
    "paddle.ones_like": {
        "torch_api": "torch.ones_like",
        "paddle_torch_args_map": {
            "x": "input",
            "dtype": "dtype"
        }
    },
    "paddle.outer": {
        "Rule": "OuterRule",
        "torch_api": "torch.outer",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "vec2"
        }
    },
    "paddle.Tensor.outer": {
        "Rule": "TensorOuterRule",
        "torch_api": "torch.Tensor.outer",
        "paddle_torch_args_map": {
            "y": "vec2"
        }
    },
    "paddle.pdist": {
        "torch_api": "torch.nn.functional.pdist",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p"
        }
    },
    "paddle.poisson": {
        "torch_api": "torch.poisson",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.polar": {
        "Rule": "PolarRule"
    },
    "paddle.polygamma": {
        "torch_api": "torch.special.polygamma",
        "paddle_torch_args_map": {
            "n": "n",
            "x": "input"
        }
    },
    "paddle.positive": {
        "Rule": "PositiveRule"
    },
    "paddle.pow": {
        "torch_api": "torch.pow",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "exponent"
        }
    },
    "paddle.Tensor.pow": {
        "torch_api": "torch.Tensor.pow",
        "paddle_torch_args_map": {
            "y": "exponent"
        }
    },
    "paddle.prod": {
        "Rule": "ReduceRule",
        "torch_api": "torch.prod",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False",
            "dtype": "None"
        }
    },
    "paddle.Tensor.prod": {
        "torch_api": "torch.Tensor.prod",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.put_along_axis": {
        "Rule": "Put_along_axisRule"
    },
    "paddle.Tensor.put_along_axis": {
        "Rule": "Put_along_axisRule"
    },
    "paddle.quantile": {
        "Rule": "QuantileRule",
        "torch_api": "torch.quantile",
        "set_defaults": {
            "axis": "None",
            "keepdim": "False",
            "interpolation": "'linear'"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "q": "q",
            "axis": "dim",
            "keepdim": "keepdim",
            "interpolation": "interpolation"
        }
    },
    "paddle.Tensor.quantile": {
        "torch_api": "torch.Tensor.quantile",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim",
            "interpolation": "interpolation"
        },
        "torch_kwargs": {
            "q": "torch.tensor(q, dtype=x.dtype) if isinstance(q, (list, tuple)) else q"
        }
    },
    "paddle.rad2deg": {
        "torch_api": "torch.rad2deg",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.rad2deg": {
        "torch_api": "torch.Tensor.rad2deg"
    },
    "paddle.rank": {
        "Rule": "RankRule"
    },
    "paddle.Tensor.rank": {
        "Rule": "RankRule"
    },
    "paddle.real": {
        "torch_api": "torch.real",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.real": {
        "torch_api": "torch.Tensor.real",
        "is_attribute": true
    },
    "paddle.reciprocal": {
        "torch_api": "torch.reciprocal",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.reciprocal": {
        "torch_api": "torch.Tensor.reciprocal"
    },
    "paddle.reduce_as": {
        "Rule": "Reduce_asRule"
    },
    "paddle.remainder": {
        "torch_api": "torch.remainder",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.remainder": {
        "torch_api": "torch.Tensor.remainder",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.renorm": {
        "torch_api": "torch.renorm",
        "paddle_torch_args_map": {
            "x": "input",
            "p": "p",
            "axis": "dim",
            "max_norm": "maxnorm"
        }
    },
    "paddle.repeat_interleave": {
        "torch_api": "torch.repeat_interleave",
        "paddle_torch_args_map": {
            "x": "input",
            "repeats": "repeats",
            "axis": "dim"
        }
    },
    "paddle.Tensor.repeat_interleave": {
        "torch_api": "torch.Tensor.repeat_interleave",
        "paddle_torch_args_map": {
            "repeats": "repeats",
            "axis": "dim"
        }
    },
    "paddle.reshape": {
        "Rule": "ReshapeRule"
    },
    "paddle.Tensor.reshape": {
        "Rule": "ReshapeRule"
    },
    "paddle.reverse": {
        "Rule": "ReverseRule"
    },
    "paddle.roll": {
        "Rule": "RollRule",
        "torch_api": "torch.roll",
        "paddle_torch_args_map": {
            "x": "input",
            "shifts": "shifts",
            "axis": "dims"
        }
    },
    "paddle.Tensor.roll": {
        "Rule": "RollRule",
        "torch_api": "torch.Tensor.roll",
        "paddle_torch_args_map": {
            "shifts": "shifts",
            "axis": "dims"
        }
    },
    "paddle.rot90": {
        "torch_api": "torch.rot90",
        "paddle_torch_args_map": {
            "x": "input",
            "k": "k",
            "axes": "dims"
        }
    },
    "paddle.Tensor.rot90": {
        "torch_api": "torch.Tensor.rot90",
        "paddle_torch_args_map": {
            "k": "k",
            "axes": "dims"
        }
    },
    "paddle.round": {
        "torch_api": "torch.round",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.round": {
        "torch_api": "torch.Tensor.round",
        "torch_kwargs": {
            "decimals": 0
        }
    },
    "paddle.row_stack": {
        "torch_api": "torch.row_stack",
        "paddle_torch_args_map": {
            "x": "tensors"
        }
    },
    "paddle.rsqrt": {
        "torch_api": "torch.rsqrt",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.rsqrt": {
        "torch_api": "torch.Tensor.rsqrt"
    },
    "paddle.scale": {
        "Rule": "ScaleRule",
        "set_defaults": {
            "scale": 1.0,
            "bias": 0.0,
            "bias_after_scale": true,
            "act": "None"
        }
    },
    "paddle.Tensor.scale": {
        "Rule": "ScaleRule",
        "set_defaults": {
            "scale": 1.0,
            "bias": 0.0,
            "bias_after_scale": true,
            "act": "None"
        }
    },
    "paddle.scatter": {
        "Rule": "ScatterRule"
    },
    "paddle.scatter_nd": {
        "Rule": "ScatterndRule"
    },
    "paddle.scatter_nd_add": {
        "Rule": "ScatterndaddRule"
    },
    "paddle.searchsorted": {
        "torch_api": "torch.searchsorted",
        "paddle_torch_args_map": {
            "sorted_sequence": "sorted_sequence",
            "values": "input",
            "out_int32": "out_int32",
            "right": "right"
        }
    },
    "paddle.select_scatter": {
        "torch_api": "torch.select_scatter",
        "paddle_torch_args_map": {
            "x": "input",
            "values": "src",
            "axis": "dim",
            "index": "index"
        }
    },
    "paddle.sgn": {
        "torch_api": "torch.sgn",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.shape": {
        "Rule": "ShapeRule"
    },
    "paddle.shard_index": {
        "Rule": "ShardIndex"
    },
    "paddle.sign": {
        "torch_api": "torch.sgn",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.sign": {
        "torch_api": "torch.Tensor.sign"
    },
    "paddle.signal.istft": {
        "torch_api": "torch.istft",
        "paddle_torch_args_map": {
            "x": "input",
            "n_fft": "n_fft",
            "hop_length": "hop_length",
            "win_length": "win_length",
            "window": "window",
            "center": "center",
            "normalized": "normalized",
            "onesided": "onesided",
            "length": "length",
            "return_complex": "return_complex"
        }
    },
    "paddle.signal.stft": {
        "torch_api": "torch.stft",
        "paddle_torch_args_map": {
            "x": "input",
            "n_fft": "n_fft",
            "hop_length": "hop_length",
            "win_length": "win_length",
            "window": "window",
            "center": "center",
            "pad_mode": "pad_mode",
            "onesided": "onesided",
            "normalized": "normalized"
        },
        "torch_kwargs": {
            "return_complex": "True"
        }
    },
    "paddle.signbit": {
        "torch_api": "torch.signbit",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.signbit": {
        "torch_api": "torch.Tensor.signbit",
        "paddle_torch_args_map": {}
    },
    "paddle.sin": {
        "torch_api": "torch.sin",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.sin": {
        "torch_api": "torch.Tensor.sin"
    },
    "paddle.sinc": {
        "torch_api": "torch.special.sinc",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.sinh": {
        "torch_api": "torch.sinh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.slice": {
        "Rule": "SliceRule"
    },
    "paddle.Tensor.slice": {
        "Rule": "SliceRule"
    },
    "paddle.slice_scatter": {
        "Rule": "SliceScatterRule"
    },
    "paddle.Tensor.slice_scatter": {
        "torch_api": "torch.Tensor.slice_scatter",
        "paddle_torch_args_map": {
            "value": "src"
        },
        "torch_kwargs": {
            "dim": "axes[0] if isinstance(axes, list) else axes",
            "start": "starts[0] if isinstance(starts, list) else starts",
            "end": "ends[0] if isinstance(ends, list) else ends",
            "step": "strides[0] if isinstance(strides, list) else strides"
        }
    },
    "paddle.sort": {
        "Rule": "SortRule",
        "torch_api": "torch.sort",
        "set_defaults": {
            "axis": "-1",
            "stable": "False",
            "descending": "False"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "stable": "stable",
            "descending": "descending"
        }
    },
    "paddle.Tensor.sort": {
        "Rule": "SortRule",
        "torch_api": "torch.Tensor.sort",
        "set_defaults": {
            "axis": "-1",
            "stable": "False",
            "descending": "False"
        },
        "paddle_torch_args_map": {
            "axis": "dim",
            "stable": "stable",
            "descending": "descending"
        }
    },
    "paddle.sparse.addmm": {
        "torch_api": "torch.sparse.addmm",
        "paddle_torch_args_map": {
            "input": "input",
            "x": "mat1",
            "y": "mat2",
            "beta": "beta",
            "alpha": "alpha"
        }
    },
    "paddle.sparse.matmul": {
        "torch_api": "torch.sparse.mm",
        "paddle_torch_args_map": {
            "x": "sparse",
            "y": "dense"
        }
    },
    "paddle.split": {
        "Rule": "SplitRule"
    },
    "paddle.Tensor.split": {
        "Rule": "SplitTensorRule",
        "torch_api": "torch.Tensor.split",
        "set_defaults": {
            "axis": "0"
        },
        "paddle_torch_args_map": {
            "axis": "dim",
            "num_or_sections": "split_size"
        }
    },
    "paddle.sqrt": {
        "torch_api": "torch.sqrt",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.sqrt": {
        "torch_api": "torch.Tensor.sqrt"
    },
    "paddle.square": {
        "torch_api": "torch.square",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.square": {
        "torch_api": "torch.Tensor.square"
    },
    "paddle.squeeze": {
        "Rule": "SqueezeRule",
        "torch_api": "torch.squeeze",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim"
        }
    },
    "paddle.Tensor.squeeze": {
        "torch_api": "torch.Tensor.squeeze",
        "paddle_torch_args_map": {
            "axis": "dim"
        }
    },
    "paddle.stack": {
        "torch_api": "torch.stack",
        "paddle_torch_args_map": {
            "x": "tensors",
            "axis": "dim"
        }
    },
    "paddle.standard_gamma": {
        "Rule": "StandardGammaRule",
        "torch_api": "torch.distributions.Gamma",
        "paddle_torch_args_map": {
            "x": "concentration",
            "rate": "rate"
        }
    },
    "paddle.standard_normal": {
        "torch_api": "torch.randn",
        "set_defaults": {
            "dtype": "None"
        },
        "paddle_torch_args_map": {
            "shape": "size",
            "dtype": "dtype"
        }
    },
    "paddle.stanh": {
        "Rule": "StanhRule",
        "torch_api": "torch.tanh",
        "set_defaults": {
            "scale_a": "0.67",
            "scale_b": "1.7159"
        },
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.std": {
        "torch_api": "torch.std",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "unbiased": "correction",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.std": {
        "torch_api": "torch.Tensor.std",
        "paddle_torch_args_map": {
            "axis": "dim",
            "unbiased": "correction",
            "keepdim": "keepdim"
        }
    },
    "paddle.strided_slice": {
        "Rule": "StridedSliceRule"
    },
    "paddle.subtract": {
        "Rule": "SubtractRule",
        "torch_api": "torch.subtract",
        "paddle_torch_args_map": {
            "x": "input",
            "y": "other"
        }
    },
    "paddle.Tensor.subtract": {
        "torch_api": "torch.Tensor.subtract",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.sum": {
        "Rule": "ReduceRule",
        "torch_api": "torch.sum",
        "set_defaults": {
            "axis": "None",
            "keepdim": false,
            "dtype": "None"
        }
    },
    "paddle.Tensor.sum": {
        "torch_api": "torch.Tensor.sum",
        "paddle_torch_args_map": {
            "axis": "dim",
            "keepdim": "keepdim",
            "dtype": "dtype"
        }
    },
    "paddle.t": {
        "torch_api": "torch.t",
        "paddle_torch_args_map": {
            "input": "input"
        }
    },
    "paddle.take": {
        "Rule": "TakeRule",
        "paddle_torch_args_map": {
            "x": "input",
            "index": "index"
        }
    },
    "paddle.take_along_axis": {
        "torch_api": "torch.take_along_dim",
        "paddle_torch_args_map": {
            "arr": "input",
            "axis": "dim"
        },
        "torch_kwargs": {
            "indices": "indices.to(torch.int64) if indices.dtype != torch.int64 else indices"
        }
    },
    "paddle.Tensor.take_along_axis": {
        "torch_api": "torch.Tensor.take_along_dim",
        "paddle_torch_args_map": {
            "axis": "dim"
        },
        "torch_kwargs": {
            "indices": "indices.to(torch.int64) if indices.dtype != torch.int64 else indices"
        }
    },
    "paddle.tan": {
        "torch_api": "torch.tan",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.tanh": {
        "torch_api": "torch.tanh",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.Tensor.tanh": {
        "torch_api": "torch.Tensor.tanh"
    },
    "paddle.tensor_split": {
        "torch_api": "torch.tensor_split",
        "set_defaults": {
            "axis": 0
        },
        "torch_args": [
            "x",
            "num_or_indices",
            "axis"
        ]
    },
    "paddle.tensordot": {
        "Rule": "TensordotRule",
        "torch_api": "torch.tensordot",
        "set_defaults": {
            "axes": 2
        },
        "paddle_torch_args_map": {
            "x": "a",
            "y": "b",
            "axes": "dims"
        }
    },
    "paddle.tile": {
        "torch_api": "torch.tile",
        "paddle_torch_args_map": {
            "x": "input"
        },
        "torch_kwargs": {
            "dims": "repeat_times.tolist() if isinstance(repeat_times, torch.Tensor) else repeat_times"
        }
    },
    "paddle.Tensor.tile": {
        "torch_api": "torch.Tensor.tile",
        "paddle_torch_args_map": {
            "repeat_times": "dims"
        }
    },
    "paddle.tolist": {
        "Rule": "TolistRule",
        "torch_api": "torch.Tensor.tolist"
    },
    "paddle.Tensor.tolist": {
        "torch_api": "torch.Tensor.tolist"
    },
    "paddle.topk": {
        "torch_api": "torch.topk",
        "paddle_torch_args_map": {
            "x": "input",
            "k": "k",
            "axis": "dim",
            "largest": "largest",
            "sorted": "sorted"
        }
    },
    "paddle.Tensor.topk": {
        "torch_api": "torch.Tensor.topk",
        "paddle_torch_args_map": {
            "k": "k",
            "axis": "dim",
            "largest": "largest",
            "sorted": "sorted"
        }
    },
    "paddle.trace": {
        "Rule": "TraceRule",
        "paddle_torch_args_map": {
            "x": "input",
            "offset": "offset",
            "axis1": "dim1",
            "axis2": "dim2"
        }
    },
    "paddle.transpose": {
        "torch_api": "torch.permute",
        "paddle_torch_args_map": {
            "x": "input"
        },
        "torch_kwargs": {
            "dims": "tuple(perm) + tuple(range(len(perm), x.ndim))"
        }
    },
    "paddle.Tensor.transpose": {
        "torch_api": "torch.Tensor.permute",
        "paddle_torch_args_map": {
            "perm": "dims"
        }
    },
    "paddle.trapezoid": {
        "Rule": "TrapezoidRule",
        "torch_api": "torch.trapezoid",
        "paddle_torch_args_map": {
            "y": "y",
            "x": "x",
            "dx": "dx",
            "axis": "dim"
        }
    },
    "paddle.tril": {
        "torch_api": "torch.tril",
        "paddle_torch_args_map": {
            "x": "input",
            "diagonal": "diagonal"
        }
    },
    "paddle.Tensor.tril": {
        "torch_api": "torch.Tensor.tril",
        "paddle_torch_args_map": {
            "diagonal": "diagonal"
        }
    },
    "paddle.tril_indices": {
        "torch_api": "torch.tril_indices",
        "paddle_torch_args_map": {
            "row": "row",
            "offset": "offset",
            "dtype": "dtype"
        },
        "torch_kwargs": {
            "col": "row if col is None else col"
        }
    },
    "paddle.triu": {
        "torch_api": "torch.triu",
        "paddle_torch_args_map": {
            "x": "input",
            "diagonal": "diagonal"
        }
    },
    "paddle.triu_indices": {
        "torch_api": "torch.triu_indices",
        "paddle_torch_args_map": {
            "row": "row",
            "offset": "offset",
            "dtype": "dtype"
        },
        "torch_kwargs": {
            "col": "row if col is None else col"
        }
    },
    "paddle.trunc": {
        "torch_api": "torch.trunc",
        "paddle_torch_args_map": {
            "input": "input"
        }
    },
    "paddle.Tensor.trunc": {
        "torch_api": "torch.Tensor.trunc"
    },
    "paddle.unbind": {
        "torch_api": "torch.unbind",
        "paddle_torch_args_map": {
            "input": "input",
            "axis": "dim"
        }
    },
    "paddle.Tensor.unbind": {
        "torch_api": "torch.Tensor.unbind",
        "paddle_torch_args_map": {
            "axis": "dim"
        }
    },
    "paddle.unflatten": {
        "Rule": "UnflattenRule",
        "torch_api": "torch.unflatten",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "shape": "sizes"
        }
    },
    "paddle.Tensor.unflatten": {
        "torch_api": "torch.Tensor.unflatten",
        "paddle_torch_args_map": {
            "axis": "dim",
            "shape": "sizes"
        }
    },
    "paddle.unfold": {
        "Rule": "UnfoldRule",
        "torch_api": "torch.Tensor.unfold",
        "paddle_torch_args_map": {
            "axis": "dimension",
            "size": "size",
            "step": "step"
        }
    },
    "paddle.unique": {
        "Rule": "UniqueRule",
        "torch_api": "torch.unique",
        "set_defaults": {
            "return_index": false,
            "return_inverse": false,
            "return_counts": false,
            "axis": "None",
            "dtype": "torch.int64"
        },
        "paddle_torch_args_map": {
            "x": "input",
            "return_inverse": "return_inverse",
            "return_counts": "return_counts",
            "axis": "dim"
        }
    },
    "paddle.Tensor.unique": {
        "torch_api": "torch.Tensor.unique",
        "paddle_torch_args_map": {
            "return_inverse": "return_inverse",
            "return_counts": "return_counts",
            "axis": "dim"
        }
    },
    "paddle.unique_consecutive": {
        "Rule": "UniqueConsecutiveRule",
        "torch_api": "torch.unique_consecutive"
    },
    "paddle.unsqueeze": {
        "Rule": "UnsqueezeRule",
        "torch_api": "torch.unsqueeze",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim"
        }
    },
    "paddle.Tensor.unsqueeze": {
        "Rule": "UnsqueezeRule",
        "torch_api": "torch.Tensor.unsqueeze",
        "paddle_torch_args_map": {
            "axis": "dim"
        }
    },
    "paddle.unstack": {
        "torch_api": "torch.unbind",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim"
        }
    },
    "paddle.vander": {
        "Rule": "VanderRule"
    },
    "paddle.var": {
        "torch_api": "torch.var",
        "paddle_torch_args_map": {
            "x": "input",
            "axis": "dim",
            "unbiased": "correction",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.var": {
        "torch_api": "torch.Tensor.var",
        "paddle_torch_args_map": {
            "axis": "dim",
            "unbiased": "correction",
            "keepdim": "keepdim"
        }
    },
    "paddle.vecdot": {
        "Rule": "VecdotRule"
    },
    "paddle.view": {
        "Rule": "ViewRule"
    },
    "paddle.view_as": {
        "Rule": "View_As_Rule"
    },
    "paddle.vision.ops.deform_conv2d": {
        "Rule": "DeformConv2dRule",
        "torch_api": "torchvision.ops.deform_conv2d",
        "paddle_torch_args_map": {
            "x": "input",
            "offset": "offset",
            "weight": "weight",
            "bias": "bias",
            "stride": "stride",
            "padding": "padding",
            "dilation": "dilation",
            "mask": "mask"
        }
    },
    "paddle.vision.ops.distribute_fpn_proposals": {
        "Rule": "Distribute_fpn_proposalsRule"
    },
    "paddle.vision.ops.generate_proposals": {
        "Rule": "GenerateProposalsRule"
    },
    "paddle.vision.ops.nms": {
        "Rule": "NmsRule"
    },
    "paddle.vision.ops.psroi_pool": {
        "Rule": "Roi_poolRule",
        "torch_api": "torchvision.ops.ps_roi_pool"
    },
    "paddle.vision.ops.roi_align": {
        "Rule": "Roi_aignRule"
    },
    "paddle.vision.ops.roi_pool": {
        "Rule": "Roi_poolRule",
        "torch_api": "torchvision.ops.roi_pool"
    },
    "paddle.vsplit": {
        "Rule": "SsplitRule",
        "torch_api": "torch.vsplit",
        "paddle_torch_args_map": {
            "x": "input"
        }
    },
    "paddle.vstack": {
        "torch_api": "torch.vstack",
        "paddle_torch_args_map": {
            "x": "tensors"
        }
    },
    "paddle.where": {
        "Rule": "WhereRule"
    },
    "paddle.zeros": {
        "Rule": "ZerosRule"
    },
    "paddle.zeros_like": {
        "torch_api": "torch.zeros_like",
        "paddle_torch_args_map": {
            "x": "input",
            "dtype": "dtype"
        }
    },
    "paddle.Tensor.__abs__": {
        "torch_api": "torch.Tensor.__abs__"
    },
    "paddle.Tensor.__add__": {
        "torch_api": "torch.Tensor.__add__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__add__(other=y)"
    },
    "paddle.Tensor.__and__": {
        "torch_api": "torch.Tensor.__and__",
        "paddle_torch_args_map": {
            "y": "other"
        }
    },
    "paddle.Tensor.__dir__": {
        "torch_api": "torch.Tensor.__dir__"
    },
    "paddle.Tensor.__div__": {
        "torch_api": "torch.Tensor.__div__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__div__(other=y)"
    },
    "paddle.Tensor.__eq__": {
        "torch_api": "torch.Tensor.__eq__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__eq__(other=y)"
    },
    "paddle.Tensor.__floordiv__": {
        "torch_api": "torch.Tensor.__floordiv__",
        "torch_kwargs": {
            "other": "y if isinstance(y, torch.Tensor) else torch.tensor([y], dtype=_tmp_tensor.dtype if (isinstance(y, int) and 'int' in str(_tmp_tensor.dtype)) or (isinstance(y, float) and 'float' in str(_tmp_tensor.dtype)) else None)"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__floordiv__(other=y)"
    },
    "paddle.Tensor.__ge__": {
        "torch_api": "torch.Tensor.__ge__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__ge__(other=y)"
    },
    "paddle.Tensor.__getitem__": {
        "torch_api": "torch.Tensor.__getitem__"
    },
    "paddle.Tensor.__gt__": {
        "torch_api": "torch.Tensor.__gt__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__gt__(other=y)"
    },
    "paddle.Tensor.__invert__": {
        "torch_api": "torch.Tensor.__invert__",
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__invert__()"
    },
    "paddle.Tensor.__le__": {
        "torch_api": "torch.Tensor.__le__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__le__(other=y)"
    },
    "paddle.Tensor.__len__": {
        "torch_api": "torch.Tensor.__len__"
    },
    "paddle.Tensor.__lshift__": {
        "torch_api": "torch.Tensor.__lshift__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__lshift__(other=y)"
    },
    "paddle.Tensor.__lt__": {
        "torch_api": "torch.Tensor.__lt__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__lt__(other=y)"
    },
    "paddle.Tensor.__matmul__": {
        "torch_api": "torch.Tensor.__matmul__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__matmul__(other=y)"
    },
    "paddle.Tensor.__mod__": {
        "torch_api": "torch.Tensor.__mod__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__mod__(other=y)"
    },
    "paddle.Tensor.__mul__": {
        "torch_api": "torch.Tensor.__mul__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__mul__(other=y)"
    },
    "paddle.Tensor.__ne__": {
        "torch_api": "torch.Tensor.__ne__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__ne__(other=y)"
    },
    "paddle.Tensor.__neg__": {
        "torch_api": "torch.Tensor.__neg__",
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__neg__()"
    },
    "paddle.Tensor.__nonzero__": {
        "Rule": "NonzeroRule",
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__gt__(0)"
    },
    "paddle.Tensor.__or__": {
        "torch_api": "torch.Tensor.__or__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__or__(other=y)"
    },
    "paddle.Tensor.__pow__": {
        "Rule": "__Pow__Rule",
        "description": "use rule since torch.Tensor.__pow__(other=y) throws unimplemented error"
    },
    "paddle.Tensor.__radd__": {
        "torch_api": "torch.Tensor.__radd__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__radd__(other=y)"
    },
    "paddle.Tensor.__rlshift__": {
        "torch_api": "torch.Tensor.__rlshift__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rlshift__(other=y)"
    },
    "paddle.Tensor.__rmatmul__": {
        "torch_api": "torch.Tensor.__rmatmul__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rmatmul__(other=y)"
    },
    "paddle.Tensor.__rmod__": {
        "torch_api": "torch.Tensor.__rmod__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rmod__(other=y)"
    },
    "paddle.Tensor.__rmul__": {
        "torch_api": "torch.Tensor.__rmul__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rmul__(other=y)"
    },
    "paddle.Tensor.__ror__": {
        "torch_api": "torch.Tensor.__ror__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__ror__(other=y)"
    },
    "paddle.Tensor.__rpow__": {
        "torch_api": "torch.Tensor.__rpow__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rpow__(other=y)"
    },
    "paddle.Tensor.__rrshift__": {
        "torch_api": "torch.Tensor.__rrshift__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rrshift__(other=y)"
    },
    "paddle.Tensor.__rshift__": {
        "Rule": "__rshift__Rule"
    },
    "paddle.Tensor.__rsub__": {
        "torch_api": "torch.Tensor.__rsub__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rsub__(other=y)"
    },
    "paddle.Tensor.__rtruediv__": {
        "torch_api": "torch.Tensor.__rtruediv__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rtruediv__(other=y)"
    },
    "paddle.Tensor.__rxor__": {
        "torch_api": "torch.Tensor.__rxor__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__rxor__(other=y)"
    },
    "paddle.Tensor.__setitem__": {
        "Rule": "SetitemRule",
        "torch_api": "torch.Tensor.__setitem__"
    },
    "paddle.Tensor.__sub__": {
        "torch_api": "torch.Tensor.__sub__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__sub__(other=y)"
    },
    "paddle.Tensor.__truediv__": {
        "torch_api": "torch.Tensor.__truediv__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__truediv__(other=y)"
    },
    "paddle.Tensor.__xor__": {
        "torch_api": "torch.Tensor.__xor__",
        "paddle_torch_args_map": {
            "y": "other"
        },
        "description": "_tmp_tensor = arg[0], result = _tmp_tensor.__xor__(other=y)"
    },
    "paddle.Tensor.astype": {
        "torch_api": "torch.Tensor.to",
        "paddle_torch_args_map": {
            "dtype": "dtype"
        },
        "description": "_tmp_tensor_ = args[0], result = _tmp_tensor_.to(dtype=dtype)"
    },
    "paddle.Tensor.bernoulli_": {
        "torch_api": "torch.Tensor.bernoulli_",
        "paddle_torch_args_map": {
            "p": "p"
        }
    },
    "paddle.Tensor.cauchy_": {
        "torch_api": "torch.Tensor.cauchy_",
        "paddle_torch_args_map": {
            "loc": "median",
            "scale": "sigma"
        }
    },
    "paddle.Tensor.cholesky_solve": {
        "torch_api": "torch.Tensor.cholesky_solve",
        "paddle_torch_args_map": {
            "y": "input2",
            "upper": "upper"
        }
    },
    "paddle.Tensor.coalesce": {
        "torch_api": "torch.Tensor.coalesce"
    },
    "paddle.Tensor.detach": {
        "torch_api": "torch.Tensor.detach"
    },
    "paddle.Tensor.dim": {
        "torch_api": "torch.Tensor.dim"
    },
    "paddle.Tensor.exponential_": {
        "torch_api": "torch.Tensor.exponential_",
        "paddle_torch_args_map": {
            "lam": "lambd"
        },
        "torch_kwargs": {
            "generator": "None"
        }
    },
    "paddle.Tensor.fill_": {
        "torch_api": "torch.Tensor.fill_",
        "paddle_torch_args_map": {
            "value": "value"
        }
    },
    "paddle.Tensor.fill_diagonal_": {
        "Rule": "FillDiagonal_Rule",
        "torch_api": "torch.Tensor.fill_diagonal_",
        "set_defaults": {
            "offset": 0,
            "wrap": "False"
        },
        "paddle_torch_args_map": {
            "value": "fill_value",
            "wrap": "wrap"
        }
    },
    "paddle.Tensor.fill_diagonal_tensor": {
        "Rule": "FillDiagonalTensorRule"
    },
    "paddle.Tensor.geometric_": {
        "torch_api": "torch.Tensor.geometric_",
        "paddle_torch_args_map": {
            "probs": "p"
        },
        "torch_kwargs": {
            "generator": "None"
        }
    },
    "paddle.Tensor.inverse": {
        "torch_api": "torch.Tensor.inverse"
    },
    "paddle.Tensor.is_coalesced": {
        "torch_api": "torch.Tensor.is_coalesced"
    },
    "paddle.Tensor.item": {
        "Rule": "ItemRule"
    },
    "paddle.Tensor.log_normal_": {
        "torch_api": "torch.Tensor.log_normal_",
        "paddle_torch_args_map": {
            "mean": "mean",
            "std": "std"
        }
    },
    "paddle.Tensor.lu": {
        "torch_api": "torch.Tensor.lu",
        "paddle_torch_args_map": {
            "pivot": "pivot",
            "get_infos": "get_infos"
        }
    },
    "paddle.Tensor.norm": {
        "torch_api": "torch.Tensor.norm",
        "paddle_torch_args_map": {
            "p": "p",
            "axis": "dim",
            "keepdim": "keepdim"
        }
    },
    "paddle.Tensor.normal_": {
        "torch_api": "torch.Tensor.normal_",
        "paddle_torch_args_map": {
            "mean": "mean",
            "std": "std"
        },
        "torch_kwargs": {
            "generator": "None"
        }
    },
    "paddle.Tensor.set_": {
        "torch_api": "torch.Tensor.set_",
        "paddle_torch_args_map": {
            "stride": "stride"
        },
        "torch_kwargs": {
            "source": "source if locals().get('source') is not None else torch.empty([])",
            "size": "locals().get('shape') or (source.size() if locals().get('source') is not None else [])",
            "storage_offset": "(locals().get('offset') or 0) // _tmp_tensor.itemsize"
        }
    },
    "paddle.Tensor.sigmoid": {
        "torch_api": "torch.Tensor.sigmoid"
    },
    "paddle.Tensor.zero_": {
        "torch_api": "torch.Tensor.zero_"
    }
}